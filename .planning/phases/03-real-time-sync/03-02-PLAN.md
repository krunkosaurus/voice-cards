---
phase: 03-real-time-sync
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - client/src/contexts/SyncContext.tsx
  - client/src/services/sync/projectSync.ts
autonomous: true

must_haves:
  truths:
    - "Remote operations are applied to local state without re-broadcasting"
    - "isApplyingRemoteRef flag prevents infinite loops"
    - "Card creates, updates, deletes, reorders, and audio changes apply correctly"
  artifacts:
    - path: "client/src/contexts/SyncContext.tsx"
      provides: "Operation handler and isApplyingRemoteRef"
      contains: "isApplyingRemoteRef"
    - path: "client/src/services/sync/projectSync.ts"
      provides: "applyRemoteCardOp utility functions"
      exports: ["applyRemoteCardCreate", "applyRemoteCardUpdate", "applyRemoteCardDelete", "applyRemoteCardReorder", "applyRemoteCardAudioChange"]
  key_links:
    - from: "client/src/contexts/SyncContext.tsx"
      to: "client/src/services/sync/projectSync.ts"
      via: "imports apply functions"
      pattern: "import.*applyRemoteCard"
    - from: "client/src/contexts/SyncContext.tsx"
      to: "isOperationMessage"
      via: "type guard in message handler"
      pattern: "isOperationMessage"
---

<objective>
Add operation handlers to SyncContext for receiving and applying remote operations.

Purpose: Enable viewer (and editor during role swap) to receive operations and apply them locally without re-broadcasting.

Output: SyncContext extended with operation handling; projectSync with apply functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time-sync/03-RESEARCH.md
@.planning/phases/03-real-time-sync/03-01-SUMMARY.md

# Files to extend
@client/src/contexts/SyncContext.tsx
@client/src/services/sync/projectSync.ts
@client/src/services/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add apply functions to projectSync.ts</name>
  <files>client/src/services/sync/projectSync.ts</files>
  <action>
Add utility functions for applying remote operations to IndexedDB.

These functions handle the persistence side - they write to IndexedDB. State updates are handled separately in SyncContext.

1. applyRemoteCardCreate(card: Card, audioBlob?: Blob):
   - Call saveCard(card) from db.ts
   - If audioBlob provided, call saveAudio(card.id, audioBlob)
   - No return value (void)

2. applyRemoteCardUpdate(cardId: string, changes: Partial<Pick<Card, 'label' | 'notes' | 'tags' | 'color'>>, existingCard: Card):
   - Merge changes into existingCard with updatedAt = new Date().toISOString()
   - Call saveCard(mergedCard)
   - Return the merged card

3. applyRemoteCardDelete(cardId: string):
   - Call deleteCard(cardId) from db.ts (this also deletes audio)
   - No return value

4. applyRemoteCardReorder(cardOrder: Array<{ id: string; order: number }>, existingCards: Card[]):
   - Create orderLookup Map from cardOrder
   - Map existingCards to update their order field
   - Sort by new order
   - Call saveCards(reorderedCards)
   - Return the reordered cards array

5. applyRemoteCardAudioChange(cardId: string, metadata: { duration: number; waveformData?: number[]; transcript?: TranscriptSegment[] }, existingCard: Card, audioBlob: Blob):
   - Merge metadata into existingCard with updatedAt = new Date().toISOString()
   - Call saveCard(mergedCard)
   - Call saveAudio(cardId, audioBlob)
   - Return the merged card

Import saveCard, saveCards, deleteCard, saveAudio from @/services/db.
Import Card and TranscriptSegment types.
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>All five apply functions exported and use existing db.ts functions</done>
</task>

<task type="auto">
  <name>Task 2: Add operation handler to SyncContext</name>
  <files>client/src/contexts/SyncContext.tsx</files>
  <action>
Extend SyncContext to handle operation messages with origin-based deduplication.

1. Add isApplyingRemoteRef (useRef<boolean>(false)):
   - Tracks whether we're currently applying a remote operation
   - CRITICAL: Must be set true BEFORE dispatching, false AFTER (in finally block)
   - Expose via context value for broadcast wrappers to check

2. Add pendingAudioOps state (Map<string, { metadata: any; receivedBlob: Blob | null }>):
   - Tracks audio change operations awaiting binary data
   - When op_card_audio_change received, store metadata
   - When binary transfer completes for that cardId, apply the full change

3. Update handleSyncMessage to route operation messages:
   - Import isOperationMessage from syncProtocol.ts
   - After existing isSyncControlMessage check, add isOperationMessage check
   - Route to handleOperationMessage(msg as SyncOperation)

4. Add handleOperationMessage(op: SyncOperation):
   - Set isApplyingRemoteRef.current = true
   - Use try/finally to ensure flag is reset
   - Switch on op.type:

   case 'op_card_create':
     - Import applyRemoteCardCreate
     - Create Card from op.card
     - dispatch ADD_CARD
     - Call applyRemoteCardCreate(card) for persistence
     - If op.audioSize > 0, audio will arrive via chunk protocol (handled by existing chunk handlers)

   case 'op_card_update':
     - Find existing card in state
     - If not found, log warning and return
     - Merge changes, dispatch UPDATE_CARD
     - Call applyRemoteCardUpdate for persistence

   case 'op_card_delete':
     - dispatch DELETE_CARD with op.cardId
     - Call applyRemoteCardDelete for persistence

   case 'op_card_reorder':
     - Get cards from state
     - Call applyRemoteCardReorder to get reordered array
     - dispatch REORDER_CARDS with result

   case 'op_card_audio_change':
     - Store in pendingAudioOps with cardId as key
     - Audio will arrive via chunk_start/binary/chunk_complete
     - When audio completes for this cardId, apply the full change

5. Update handleBinaryMessage completion:
   - When chunk completes and audio blob is assembled
   - Check if cardId is in pendingAudioOps
   - If so, apply the audio change (update card, save audio)
   - Remove from pendingAudioOps

6. Add to SyncContextValue:
   - isApplyingRemoteRef: React.RefObject<boolean>
   - getConnection: () => WebRTCConnectionService | null (for broadcast wrappers)
   - getAudioTransfer: () => AudioTransferService | null (for audio broadcasts)
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>Operation handler routes all five operation types, isApplyingRemoteRef prevents re-broadcast, audio changes handled via pendingAudioOps</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. isApplyingRemoteRef exposed in context value
3. All five operation types handled in switch statement
4. Audio change operations coordinate with binary transfer
5. Database persistence uses existing db.ts functions
</verification>

<success_criteria>
- Remote operations apply to local state
- Origin flag prevents infinite broadcast loops
- Audio changes wait for binary transfer completion
- Persistence via existing IndexedDB functions
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time-sync/03-02-SUMMARY.md`
</output>
