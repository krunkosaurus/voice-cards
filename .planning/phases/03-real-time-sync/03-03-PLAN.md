---
phase: 03-real-time-sync
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - client/src/hooks/useSyncedActions.ts
  - client/src/pages/Home.tsx
  - client/src/components/Card.tsx
autonomous: true

must_haves:
  truths:
    - "When editor creates a card, viewer sees it within 1 second (SYNC-01)"
    - "When editor deletes a card, viewer sees it disappear (SYNC-02)"
    - "When editor edits card metadata, viewer sees changes (SYNC-03)"
    - "When editor reorders cards, viewer sees new order (SYNC-04)"
    - "When editor changes audio, viewer receives updated audio (SYNC-05)"
  artifacts:
    - path: "client/src/hooks/useSyncedActions.ts"
      provides: "Sync-wrapped action functions"
      exports: ["useSyncedActions"]
    - path: "client/src/pages/Home.tsx"
      provides: "Uses synced actions for card operations"
      contains: "useSyncedActions"
    - path: "client/src/components/Card.tsx"
      provides: "Uses synced actions for card updates"
      contains: "useSyncedActions"
  key_links:
    - from: "client/src/hooks/useSyncedActions.ts"
      to: "client/src/contexts/SyncContext.tsx"
      via: "useSync hook and isApplyingRemoteRef"
      pattern: "useSync"
    - from: "client/src/hooks/useSyncedActions.ts"
      to: "client/src/services/webrtc/syncProtocol.ts"
      via: "operation message creators"
      pattern: "createCard.*Op"
---

<objective>
Create broadcast wrappers that intercept local actions and broadcast to peer.

Purpose: When editor performs an action, automatically broadcast the operation to viewer via WebRTC.

Output: useSyncedActions hook; Home.tsx and Card.tsx use synced actions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time-sync/03-RESEARCH.md
@.planning/phases/03-real-time-sync/03-01-PLAN.md
@.planning/phases/03-real-time-sync/03-02-PLAN.md

# Files to create/modify
@client/src/pages/Home.tsx
@client/src/components/Card.tsx
@client/src/contexts/SyncContext.tsx
@client/src/services/webrtc/syncProtocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useSyncedActions hook</name>
  <files>client/src/hooks/useSyncedActions.ts</files>
  <action>
Create new file client/src/hooks/useSyncedActions.ts with sync-wrapped action functions.

This hook wraps ProjectContext actions to broadcast operations when:
1. User is connected
2. User is editor role
3. Not currently applying a remote operation

```typescript
import { useCallback } from 'react';
import { useProject } from '@/contexts/ProjectContext';
import { useSync } from '@/contexts/SyncContext';
import type { Card } from '@/types';
import {
  createCardCreateOp,
  createCardUpdateOp,
  createCardDeleteOp,
  createCardReorderOp,
  createCardAudioChangeOp,
  createChunkStart,
  createChunkComplete,
  calculateTotalChunks,
} from '@/services/webrtc/syncProtocol';

export function useSyncedActions() {
  const { addCard, updateCard, deleteCard, reorderCards } = useProject();
  const {
    syncState,
    connectionState,
    isApplyingRemoteRef,
    getConnection,
    getAudioTransfer,
  } = useSync();

  // Helper: should we broadcast?
  const shouldBroadcast = useCallback(() => {
    return (
      connectionState === 'connected' &&
      syncState.role === 'editor' &&
      !isApplyingRemoteRef.current
    );
  }, [connectionState, syncState.role, isApplyingRemoteRef]);

  // Synced addCard - broadcasts op_card_create + audio chunks
  const syncedAddCard = useCallback(
    async (card: Card, audioBlob?: Blob) => {
      // Apply locally first
      addCard(card);

      // Broadcast if connected and editor
      if (shouldBroadcast()) {
        const connection = getConnection();
        if (!connection?.isReady()) return;

        const audioSize = audioBlob?.size ?? 0;
        connection.sendControl(createCardCreateOp(card, audioSize));

        // If audio exists, send via chunk protocol
        if (audioBlob && audioBlob.size > 0) {
          const audioTransfer = getAudioTransfer();
          if (!audioTransfer) return;

          const totalChunks = calculateTotalChunks(audioSize);
          connection.sendControl(
            createChunkStart(card.id, 0, totalChunks, audioSize)
          );
          await audioTransfer.sendAudio(card.id, 0, audioBlob);
          connection.sendControl(createChunkComplete(card.id, 0));
        }
      }
    },
    [addCard, shouldBroadcast, getConnection, getAudioTransfer]
  );

  // Synced updateCard - broadcasts op_card_update (metadata only)
  const syncedUpdateCard = useCallback(
    (card: Card) => {
      // Apply locally
      updateCard(card);

      // Broadcast if connected and editor
      if (shouldBroadcast()) {
        const connection = getConnection();
        if (!connection?.isReady()) return;

        // Only send metadata fields that can change
        const changes = {
          label: card.label,
          notes: card.notes,
          tags: card.tags,
          color: card.color,
        };
        connection.sendControl(createCardUpdateOp(card.id, changes));
      }
    },
    [updateCard, shouldBroadcast, getConnection]
  );

  // Synced deleteCard - broadcasts op_card_delete
  const syncedDeleteCard = useCallback(
    (cardId: string) => {
      // Apply locally
      deleteCard(cardId);

      // Broadcast if connected and editor
      if (shouldBroadcast()) {
        const connection = getConnection();
        if (!connection?.isReady()) return;

        connection.sendControl(createCardDeleteOp(cardId));
      }
    },
    [deleteCard, shouldBroadcast, getConnection]
  );

  // Synced reorderCards - broadcasts op_card_reorder
  const syncedReorderCards = useCallback(
    (cards: Card[]) => {
      // Apply locally
      reorderCards(cards);

      // Broadcast if connected and editor
      if (shouldBroadcast()) {
        const connection = getConnection();
        if (!connection?.isReady()) return;

        const cardOrder = cards.map((card, index) => ({
          id: card.id,
          order: index,
        }));
        connection.sendControl(createCardReorderOp(cardOrder));
      }
    },
    [reorderCards, shouldBroadcast, getConnection]
  );

  // Synced audio change - broadcasts op_card_audio_change + audio chunks
  const syncedAudioChange = useCallback(
    async (
      cardId: string,
      updatedCard: Card,
      audioBlob: Blob
    ) => {
      // Apply locally (card already updated by caller, this broadcasts)
      updateCard(updatedCard);

      // Broadcast if connected and editor
      if (shouldBroadcast()) {
        const connection = getConnection();
        const audioTransfer = getAudioTransfer();
        if (!connection?.isReady() || !audioTransfer) return;

        // Send operation message first
        connection.sendControl(
          createCardAudioChangeOp(
            cardId,
            updatedCard.duration,
            audioBlob.size,
            updatedCard.waveformData,
            updatedCard.transcript
          )
        );

        // Send audio via chunk protocol
        const totalChunks = calculateTotalChunks(audioBlob.size);
        connection.sendControl(
          createChunkStart(cardId, 0, totalChunks, audioBlob.size)
        );
        await audioTransfer.sendAudio(cardId, 0, audioBlob);
        connection.sendControl(createChunkComplete(cardId, 0));
      }
    },
    [updateCard, shouldBroadcast, getConnection, getAudioTransfer]
  );

  return {
    addCard: syncedAddCard,
    updateCard: syncedUpdateCard,
    deleteCard: syncedDeleteCard,
    reorderCards: syncedReorderCards,
    audioChange: syncedAudioChange,
    // Also expose raw actions for cases that shouldn't sync
    rawAddCard: addCard,
    rawUpdateCard: updateCard,
    rawDeleteCard: deleteCard,
    rawReorderCards: reorderCards,
  };
}
```
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>useSyncedActions hook exports synced versions of all card actions</done>
</task>

<task type="auto">
  <name>Task 2: Update Home.tsx to use synced actions</name>
  <files>client/src/pages/Home.tsx</files>
  <action>
Update Home.tsx to use useSyncedActions for card operations.

1. Import useSyncedActions:
   import { useSyncedActions } from '@/hooks/useSyncedActions';

2. Replace direct useProject calls for card operations:
   - Find where addCard is called (new recording creation)
   - Use const { addCard, deleteCard, reorderCards } = useSyncedActions();
   - The syncedAddCard takes (card, audioBlob?) so update call sites

3. Specifically update handleRecordingComplete or similar:
   - When creating a new card from recording
   - Call addCard(newCard, audioBlob) instead of addCard(newCard)
   - This triggers the broadcast with audio

4. Update handleDeleteCard if it exists:
   - Use the synced deleteCard

5. Update reorder handlers (onDragEnd or similar):
   - Use the synced reorderCards

Keep other useProject usage (state, dispatch, etc.) unchanged - only wrap the card mutation actions.
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>Home.tsx uses synced actions for new card creation, delete, and reorder</done>
</task>

<task type="auto">
  <name>Task 3: Update Card.tsx to use synced actions</name>
  <files>client/src/components/Card.tsx</files>
  <action>
Update Card.tsx to use useSyncedActions for card updates.

1. Import useSyncedActions:
   import { useSyncedActions } from '@/hooks/useSyncedActions';

2. Replace direct useProject calls for updateCard:
   - const { updateCard, audioChange } = useSyncedActions();

3. Find all places where card metadata is updated (label, notes, tags, color):
   - Use the synced updateCard

4. Find places where audio is re-recorded or trimmed:
   - Use audioChange(cardId, updatedCard, newAudioBlob) for audio changes
   - This broadcasts op_card_audio_change + audio chunks

5. Keep other useProject usage unchanged (state access, etc.)

Note: The component may have inline handlers or use callbacks passed from parent. Follow the existing pattern - if updates are done here, use synced actions. If done in parent, the parent should use synced actions.
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>Card.tsx uses synced actions for card updates and audio changes</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. useSyncedActions hook is exported and usable
3. Home.tsx imports and uses synced actions for card operations
4. Card.tsx imports and uses synced actions for updates
5. Audio changes use the audioChange function for proper broadcast
</verification>

<success_criteria>
- SYNC-01: Card creates broadcast to viewer (via syncedAddCard)
- SYNC-02: Card deletes broadcast to viewer (via syncedDeleteCard)
- SYNC-03: Card metadata edits broadcast to viewer (via syncedUpdateCard)
- SYNC-04: Card reorders broadcast to viewer (via syncedReorderCards)
- SYNC-05: Audio changes broadcast with audio data (via syncedAudioChange)
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time-sync/03-03-SUMMARY.md`
</output>
