---
phase: 03-real-time-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/types/sync.ts
  - client/src/services/webrtc/syncProtocol.ts
autonomous: true

must_haves:
  truths:
    - "Operation message types are defined for all sync actions (create, update, delete, reorder, audio_change)"
    - "Type guards distinguish operation messages from other control messages"
    - "Message creators return properly typed operation messages"
  artifacts:
    - path: "client/src/types/sync.ts"
      provides: "Operation type definitions"
      contains: "CardCreateOperation"
    - path: "client/src/services/webrtc/syncProtocol.ts"
      provides: "Operation message creators and type guards"
      exports: ["createCardCreateOp", "createCardUpdateOp", "createCardDeleteOp", "createCardReorderOp", "createCardAudioChangeOp", "isOperationMessage"]
  key_links:
    - from: "client/src/services/webrtc/syncProtocol.ts"
      to: "client/src/types/sync.ts"
      via: "imports operation types"
      pattern: "import.*CardCreateOperation"
---

<objective>
Extend sync types and protocol with operation message types for real-time changes.

Purpose: Define the message format for broadcasting card operations (create, update, delete, reorder, audio_change) between peers.

Output: Extended sync.ts with operation types; syncProtocol.ts with message creators and type guards.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time-sync/03-RESEARCH.md

# Existing files to extend
@client/src/types/sync.ts
@client/src/services/webrtc/syncProtocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add operation message types to sync.ts</name>
  <files>client/src/types/sync.ts</files>
  <action>
Add operation message type definitions after the existing SyncControlMessage types.

Add these new interfaces:

1. CardCreateOperation extends ControlMessage:
   - type: 'op_card_create'
   - card: Card (full card object)
   - audioSize: number (0 if no audio, triggers binary transfer if > 0)

2. CardUpdateOperation extends ControlMessage:
   - type: 'op_card_update'
   - cardId: string
   - changes: Partial<Pick<Card, 'label' | 'notes' | 'tags' | 'color'>> (only metadata, no audio fields)

3. CardDeleteOperation extends ControlMessage:
   - type: 'op_card_delete'
   - cardId: string

4. CardReorderOperation extends ControlMessage:
   - type: 'op_card_reorder'
   - cardOrder: Array<{ id: string; order: number }> (just IDs and new order values)

5. CardAudioChangeOperation extends ControlMessage:
   - type: 'op_card_audio_change'
   - cardId: string
   - duration: number
   - waveformData?: number[]
   - transcript?: Card['transcript']
   - audioSize: number (triggers binary transfer)

Add union type:
- SyncOperation = CardCreateOperation | CardUpdateOperation | CardDeleteOperation | CardReorderOperation | CardAudioChangeOperation

Update SyncControlMessage to include all operation types:
- Add all five operation types to the existing SyncControlMessage union

Import Card type from @/types if not already imported.
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>All five operation types defined, SyncOperation union exported, SyncControlMessage includes operations</done>
</task>

<task type="auto">
  <name>Task 2: Add operation message creators to syncProtocol.ts</name>
  <files>client/src/services/webrtc/syncProtocol.ts</files>
  <action>
Extend syncProtocol.ts with operation message creators.

1. Add OPERATION_MESSAGE_TYPES constant (array of operation type strings):
   - 'op_card_create', 'op_card_update', 'op_card_delete', 'op_card_reorder', 'op_card_audio_change'

2. Add isOperationMessage type guard:
   - Takes ControlMessage, returns msg is SyncOperation
   - Checks if msg.type is in OPERATION_MESSAGE_TYPES

3. Add message creators (following MessageWithoutMeta pattern):

   createCardCreateOp(card: Card, audioSize: number):
   - Returns { type: 'op_card_create', card, audioSize }

   createCardUpdateOp(cardId: string, changes: Partial<Pick<Card, 'label' | 'notes' | 'tags' | 'color'>>):
   - Returns { type: 'op_card_update', cardId, changes }

   createCardDeleteOp(cardId: string):
   - Returns { type: 'op_card_delete', cardId }

   createCardReorderOp(cardOrder: Array<{ id: string; order: number }>):
   - Returns { type: 'op_card_reorder', cardOrder }

   createCardAudioChangeOp(cardId: string, duration: number, audioSize: number, waveformData?: number[], transcript?: TranscriptSegment[]):
   - Returns { type: 'op_card_audio_change', cardId, duration, waveformData, transcript, audioSize }

Import the new operation types from @/types/sync.
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>All five message creators exported, isOperationMessage type guard works</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. All new types are exported from sync.ts
3. All message creators are exported from syncProtocol.ts
4. Type guard correctly narrows ControlMessage to SyncOperation
</verification>

<success_criteria>
- SYNC-01 through SYNC-05 have message formats defined
- Operation types follow established MessageWithoutMeta pattern
- Type guard enables safe routing of operation messages
- No new dependencies required
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time-sync/03-01-SUMMARY.md`
</output>
