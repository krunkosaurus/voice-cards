---
phase: 02-initial-sync
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - client/src/services/webrtc/connection.ts
  - client/src/services/sync/AudioTransferService.ts
autonomous: true

must_haves:
  truths:
    - "Large audio files can be sent in 16KB chunks"
    - "Sender waits for buffer to drain before flooding channel"
    - "Receiver can reassemble chunks into complete audio blob"
    - "Progress callbacks fire during transfer"
  artifacts:
    - path: "client/src/services/webrtc/connection.ts"
      provides: "Backpressure control methods"
      contains: "getBinaryBufferedAmount"
    - path: "client/src/services/sync/AudioTransferService.ts"
      provides: "Chunked audio transfer with reassembly"
      exports: ["AudioTransferService"]
  key_links:
    - from: "client/src/services/sync/AudioTransferService.ts"
      to: "client/src/services/webrtc/connection.ts"
      via: "WebRTCConnectionService usage"
      pattern: "WebRTCConnectionService"
    - from: "client/src/services/sync/AudioTransferService.ts"
      to: "client/src/services/webrtc/syncProtocol.ts"
      via: "import chunk utilities"
      pattern: "import.*syncProtocol"
---

<objective>
Implement chunked audio transfer with backpressure control to reliably send large audio files over WebRTC DataChannel.

Purpose: Audio files can be several MB. Without chunking and backpressure, the DataChannel buffer overflows and closes. This is the core data transfer mechanism for initial sync.

Output: Extended connection.ts with buffer monitoring, new AudioTransferService.ts with send/receive capabilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-initial-sync/02-RESEARCH.md
@.planning/phases/02-initial-sync/02-01-SUMMARY.md
@client/src/services/webrtc/connection.ts
@client/src/services/webrtc/syncProtocol.ts
@client/src/types/sync.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backpressure methods to WebRTCConnectionService</name>
  <files>client/src/services/webrtc/connection.ts</files>
  <action>
Add three new public methods to WebRTCConnectionService class:

1. **getBinaryBufferedAmount(): number**
   Returns this.binaryChannel?.bufferedAmount ?? 0
   Used for checking buffer state before sending.

2. **setBinaryBufferedAmountLowThreshold(threshold: number): void**
   Sets this.binaryChannel.bufferedAmountLowThreshold = threshold
   Only if binaryChannel exists.

3. **waitForBinaryBufferDrain(threshold: number = 64 * 1024): Promise<void>**
   Returns a Promise that:
   - Resolves immediately if !binaryChannel or bufferedAmount <= threshold
   - Otherwise, sets bufferedAmountLowThreshold to threshold
   - Adds one-time 'bufferedamountlow' event listener that resolves promise
   - Listener removes itself after firing

Add JSDoc comments explaining:
- These methods support backpressure during large binary transfers
- The threshold should typically be 64KB (BUFFER_THRESHOLD from syncProtocol)
- Callers should await waitForBinaryBufferDrain before each chunk send

Place these methods after sendBinary() in the class, grouped together with a comment:
// ============================================================
// Backpressure control for large binary transfers
// ============================================================
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify methods exist: grep for "getBinaryBufferedAmount" in connection.ts.
  </verify>
  <done>
Three backpressure methods added to WebRTCConnectionService. Methods are type-safe and handle null channel gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AudioTransferService</name>
  <files>client/src/services/sync/AudioTransferService.ts</files>
  <action>
Create new directory client/src/services/sync/ and new file AudioTransferService.ts:

**Imports:**
- WebRTCConnectionService from @/services/webrtc/connection
- CHUNK_SIZE, BUFFER_THRESHOLD, createBinaryChunk, parseBinaryChunk, calculateTotalChunks from @/services/webrtc/syncProtocol

**Types:**
```typescript
interface SendProgress {
  cardId: string;
  cardIndex: number;
  bytesSent: number;
  bytesTotal: number;
  chunksSent: number;
  chunksTotal: number;
}

interface ReceiveProgress {
  cardId: string;
  cardIndex: number;
  bytesReceived: number;
  bytesTotal: number;
  chunksReceived: number;
  chunksTotal: number;
}

interface ChunkBuffer {
  cardId: string;
  totalChunks: number;
  receivedChunks: Map<number, ArrayBuffer>;
  totalSize: number;
}
```

**AudioTransferService class:**

Constructor:
- Takes connection: WebRTCConnectionService
- Stores reference to connection
- Initializes internal state: buffers Map<number, ChunkBuffer>

**Sending methods:**

`async sendAudio(cardId: string, cardIndex: number, audioBlob: Blob, onProgress?: (p: SendProgress) => void): Promise<void>`
- Convert blob to ArrayBuffer: `await audioBlob.arrayBuffer()`
- Calculate totalChunks using calculateTotalChunks(arrayBuffer.byteLength)
- Loop from 0 to totalChunks:
  - Calculate slice start/end
  - Slice the ArrayBuffer
  - Create chunk with createBinaryChunk(cardIndex, chunkIndex, sliceData)
  - Await connection.waitForBinaryBufferDrain(BUFFER_THRESHOLD)
  - Call connection.sendBinary(chunk)
  - Call onProgress if provided with current state
- Return when all chunks sent

**Receiving methods:**

`startReceiving(cardIndex: number, cardId: string, totalChunks: number, totalSize: number): void`
- Create new ChunkBuffer entry in buffers Map
- Initialize with empty receivedChunks Map

`receiveChunk(data: ArrayBuffer, onProgress?: (p: ReceiveProgress) => void): { cardId: string; complete: boolean; blob?: Blob } | null`
- Parse chunk with parseBinaryChunk(data)
- Look up buffer by cardIndex
- If not found, return null (unexpected chunk)
- Store chunkData in receivedChunks Map by chunkIndex
- Call onProgress if provided
- Check if receivedChunks.size === totalChunks
- If complete:
  - Reassemble: iterate 0 to totalChunks-1, collect ArrayBuffers in order
  - Create Blob with new Blob(chunks, { type: 'audio/webm' })
  - Delete buffer from Map
  - Return { cardId, complete: true, blob }
- If not complete:
  - Return { cardId, complete: false }

`cancelReceiving(cardIndex: number): void`
- Delete buffer from Map (cleanup on error/cancel)

`getReceiveProgress(cardIndex: number): ReceiveProgress | null`
- Return current state of buffer if exists

**Export:**
- Export AudioTransferService class as default and named export
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify file exists and exports class: check file structure.
  </verify>
  <done>
AudioTransferService handles chunked send with backpressure and chunked receive with reassembly. Progress callbacks enable UI updates.
  </done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] connection.ts has getBinaryBufferedAmount, setBinaryBufferedAmountLowThreshold, waitForBinaryBufferDrain
- [ ] AudioTransferService.ts exists in client/src/services/sync/
- [ ] AudioTransferService exports sendAudio, startReceiving, receiveChunk methods
- [ ] Chunk reassembly preserves order (iterates by index, not insertion order)
</verification>

<success_criteria>
- WebRTCConnectionService extended with backpressure control
- AudioTransferService can chunk and send large blobs without buffer overflow
- AudioTransferService can receive chunks and reassemble into Blob
- Progress callbacks fire for both send and receive operations
- Audio type preserved as 'audio/webm' on reassembly
</success_criteria>

<output>
After completion, create `.planning/phases/02-initial-sync/02-02-SUMMARY.md`
</output>
