---
phase: 02-initial-sync
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - client/src/contexts/SyncContext.tsx
  - client/src/services/sync/projectSync.ts
autonomous: true

must_haves:
  truths:
    - "Sync state is tracked separately from project state"
    - "Editor can initiate sync to connected viewer"
    - "Project data can be gathered for sync transfer"
    - "Received project can be committed to local storage"
  artifacts:
    - path: "client/src/contexts/SyncContext.tsx"
      provides: "Sync state management and orchestration"
      exports: ["SyncProvider", "useSync"]
    - path: "client/src/services/sync/projectSync.ts"
      provides: "Project serialization and deserialization for sync"
      exports: ["gatherProjectForSync", "commitReceivedProject"]
  key_links:
    - from: "client/src/contexts/SyncContext.tsx"
      to: "client/src/services/sync/AudioTransferService.ts"
      via: "audio transfer coordination"
      pattern: "AudioTransferService"
    - from: "client/src/contexts/SyncContext.tsx"
      to: "client/src/services/webrtc/connection.ts"
      via: "WebRTCConnectionService"
      pattern: "sendControl"
    - from: "client/src/services/sync/projectSync.ts"
      to: "client/src/services/db.ts"
      via: "IndexedDB operations"
      pattern: "import.*from.*@/services/db"
---

<objective>
Create SyncContext for managing sync state and projectSync service for project serialization/deserialization.

Purpose: The sync operation involves multiple steps (request, accept/reject, transfer, commit). SyncContext orchestrates this flow and exposes state for UI. projectSync handles reading project data for sending and writing received data.

Output: SyncContext.tsx with provider and hook, projectSync.ts with gather/commit utilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-initial-sync/02-RESEARCH.md
@.planning/phases/02-initial-sync/02-01-SUMMARY.md
@.planning/phases/02-initial-sync/02-02-SUMMARY.md
@client/src/contexts/ProjectContext.tsx
@client/src/services/db.ts
@client/src/types/sync.ts
@client/src/services/sync/AudioTransferService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create projectSync.ts utilities</name>
  <files>client/src/services/sync/projectSync.ts</files>
  <action>
Create new file client/src/services/sync/projectSync.ts:

**Imports:**
- getProject, getAllCards, getAudio, saveProject, saveCard, saveAudio, clearAllData from @/services/db
- Card, Project from @/types
- CardMetadata from @/types/sync

**Types:**
```typescript
interface ProjectSyncData {
  project: Project;
  cards: Card[];
  audioSizes: Map<string, number>;
}

interface ReceivedProjectData {
  project: Project;
  cards: Card[];
  audioMap: Map<string, Blob>;
}
```

**Functions:**

`async function gatherProjectForSync(): Promise<ProjectSyncData>`
- Load project: await getProject()
- Load cards: await getAllCards()
- For each card, load audio and record size:
  - const blob = await getAudio(card.id)
  - If blob, audioSizes.set(card.id, blob.size)
- Return { project, cards, audioSizes }

`function cardsToMetadata(cards: Card[], audioSizes: Map<string, number>): CardMetadata[]`
- Map cards to CardMetadata array
- Include audioSize from audioSizes map (0 if not found)

`async function commitReceivedProject(data: ReceivedProjectData): Promise<void>`
- await clearAllData() - clear existing project first
- await saveProject(data.project)
- For each card in data.cards:
  - await saveCard(card)
  - const audio = data.audioMap.get(card.id)
  - If audio: await saveAudio(card.id, audio)

`async function getAudioForCard(cardId: string): Promise<Blob | null>`
- Return await getAudio(cardId)
- Wrapper for convenience in sync flow

**Export all functions.**
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify exports: grep for "export.*gatherProjectForSync" in projectSync.ts.
  </verify>
  <done>
projectSync.ts provides utilities for reading project data for sync and writing received data to IndexedDB.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SyncContext</name>
  <files>client/src/contexts/SyncContext.tsx</files>
  <action>
Create new file client/src/contexts/SyncContext.tsx:

**Imports:**
- React, createContext, useContext, useState, useCallback, useRef, useEffect from 'react'
- WebRTCConnectionService from @/services/webrtc/connection
- AudioTransferService from @/services/sync/AudioTransferService
- gatherProjectForSync, cardsToMetadata, commitReceivedProject, getAudioForCard from @/services/sync/projectSync
- SyncProgress, SyncRequestMessage, SyncControlMessage, CardMetadata from @/types/sync
- createSyncRequest, createSyncAccept, createSyncReject, createChunkStart, createChunkComplete, createSyncComplete, createSyncError, isSyncControlMessage from @/services/webrtc/syncProtocol
- Card, Project from @/types
- useProject from @/contexts/ProjectContext

**State types:**
```typescript
type SyncRole = 'sender' | 'receiver' | null;

interface SyncState {
  isSyncing: boolean;
  role: SyncRole;
  progress: SyncProgress;
  pendingRequest: SyncRequestMessage | null;
  receivedCards: Card[];
  receivedAudio: Map<string, Blob>;
}

interface SyncContextValue {
  syncState: SyncState;
  // Sender actions
  startSync: (connection: WebRTCConnectionService) => Promise<void>;
  // Receiver actions
  handleSyncRequest: (request: SyncRequestMessage) => void;
  acceptSync: () => void;
  rejectSync: (reason: string) => void;
  commitSync: () => Promise<void>;
  // Common
  cancelSync: () => void;
  handleControlMessage: (msg: ControlMessage, connection: WebRTCConnectionService) => void;
  handleBinaryMessage: (data: ArrayBuffer) => void;
}
```

**Initial state:**
```typescript
const initialProgress: SyncProgress = {
  phase: 'idle',
  currentCardIndex: 0,
  totalCards: 0,
  currentCardBytesTransferred: 0,
  currentCardBytesTotal: 0,
  totalBytesTransferred: 0,
  totalBytesTotal: 0,
};
```

**SyncProvider component:**

State:
- syncState with useState
- connectionRef with useRef<WebRTCConnectionService | null>
- audioTransferRef with useRef<AudioTransferService | null>

**startSync (sender flow):**
1. Set role='sender', isSyncing=true, phase='requesting'
2. Gather project: await gatherProjectForSync()
3. Convert to metadata: cardsToMetadata(cards, audioSizes)
4. Create request: createSyncRequest(project, cardMetadata, audioSizes)
5. Send via connection.sendControl(request)
6. Set phase='awaiting_accept'
7. Store connection and create AudioTransferService

**handleControlMessage:**
Route by message type (use isSyncControlMessage type guard):
- sync_request: If receiver, call handleSyncRequest
- sync_accept: If sender and awaiting_accept, begin transfer
- sync_reject: If sender, set error state
- chunk_start: If receiver, prepare AudioTransferService
- chunk_complete: If receiver, update progress
- sync_complete: If receiver, set phase='complete'
- sync_error: Set error state

**handleBinaryMessage (receiver):**
- Pass to audioTransferRef.current.receiveChunk
- Update progress
- If chunk complete, store blob in receivedAudio map

**Sender transfer loop (triggered by sync_accept):**
```typescript
async function performTransfer() {
  for (let i = 0; i < cards.length; i++) {
    const card = cards[i];
    const audio = await getAudioForCard(card.id);
    if (!audio) continue;

    // Send chunk_start
    connection.sendControl(createChunkStart(card.id, i, calculateTotalChunks(audio.size), audio.size));

    // Send audio chunks
    await audioTransfer.sendAudio(card.id, i, audio, (progress) => {
      updateProgress(progress);
    });

    // Send chunk_complete
    connection.sendControl(createChunkComplete(card.id, i));
  }

  // Send sync_complete
  connection.sendControl(createSyncComplete(totalCards, totalBytes));
}
```

**acceptSync (receiver):**
- Send sync_accept
- Set phase='transferring'

**rejectSync (receiver):**
- Send sync_reject
- Reset state

**commitSync (receiver):**
- Call commitReceivedProject({ project, cards, audioMap })
- Trigger ProjectContext reload via dispatch INIT_STATE with new data
- Reset sync state

**cancelSync:**
- Reset state
- Send sync_error if mid-transfer

**Provide context value with all state and actions.**

**Export SyncProvider and useSync hook.**
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify exports: grep for "export function SyncProvider" and "export function useSync" in SyncContext.tsx.
  </verify>
  <done>
SyncContext orchestrates full sync flow: sender gathers and transfers, receiver accepts and commits. Progress tracked throughout.
  </done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] projectSync.ts exports gatherProjectForSync, cardsToMetadata, commitReceivedProject
- [ ] SyncContext.tsx exports SyncProvider and useSync
- [ ] SyncProvider handles all sync control message types
- [ ] Sender flow: startSync -> awaiting_accept -> transferring -> complete
- [ ] Receiver flow: sync_request -> accept -> transferring -> complete -> commit
</verification>

<success_criteria>
- projectSync can gather full project data including audio sizes
- projectSync can commit received project to IndexedDB (clears existing first)
- SyncContext provides complete sync orchestration
- Progress state updates as chunks transfer
- Received audio stored in memory until commit
- Integration with ProjectContext for state reload after commit
</success_criteria>

<output>
After completion, create `.planning/phases/02-initial-sync/02-03-SUMMARY.md`
</output>
