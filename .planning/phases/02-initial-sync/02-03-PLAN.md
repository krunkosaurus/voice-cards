---
phase: 02-initial-sync
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - client/src/contexts/SyncContext.tsx
  - client/src/services/sync/projectSync.ts
autonomous: true

must_haves:
  truths:
    - "Sync state is tracked separately from project state"
    - "Editor can initiate sync to connected viewer"
    - "Project data can be gathered for sync transfer"
    - "Received project can be committed to local storage"
    - "Auto-sync triggers when connection established (XFER-01)"
  artifacts:
    - path: "client/src/contexts/SyncContext.tsx"
      provides: "Sync state management and orchestration"
      exports: ["SyncProvider", "useSync"]
    - path: "client/src/services/sync/projectSync.ts"
      provides: "Project serialization and deserialization for sync"
      exports: ["gatherProjectForSync", "commitReceivedProject"]
  key_links:
    - from: "client/src/contexts/SyncContext.tsx"
      to: "client/src/services/sync/AudioTransferService.ts"
      via: "audio transfer coordination"
      pattern: "AudioTransferService"
    - from: "client/src/contexts/SyncContext.tsx"
      to: "client/src/services/webrtc/connection.ts"
      via: "WebRTCConnectionService"
      pattern: "sendControl"
    - from: "client/src/services/sync/projectSync.ts"
      to: "client/src/services/db.ts"
      via: "IndexedDB operations"
      pattern: "import.*from.*@/services/db"
    - from: "client/src/contexts/SyncContext.tsx"
      to: "client/src/contexts/ProjectContext.tsx"
      via: "dispatch INIT_STATE action"
      pattern: "dispatch.*INIT_STATE"
---

<objective>
Create SyncContext for managing sync state and projectSync service for project serialization/deserialization.

Purpose: The sync operation involves multiple steps (request, accept/reject, transfer, commit). SyncContext orchestrates this flow and exposes state for UI. projectSync handles reading project data for sending and writing received data.

Output: SyncContext.tsx with provider and hook, projectSync.ts with gather/commit utilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-initial-sync/02-RESEARCH.md
@.planning/phases/02-initial-sync/02-01-SUMMARY.md
@.planning/phases/02-initial-sync/02-02-SUMMARY.md
@client/src/contexts/ProjectContext.tsx
@client/src/services/db.ts
@client/src/types/sync.ts
@client/src/services/sync/AudioTransferService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create projectSync.ts utilities</name>
  <files>client/src/services/sync/projectSync.ts</files>
  <action>
Create new file client/src/services/sync/projectSync.ts:

**Imports:**
- getProject, getAllCards, getAudio, saveProject, saveCard, saveAudio, clearAllData from @/services/db
- Card, Project from @/types
- CardMetadata from @/types/sync

**Types:**
```typescript
interface ProjectSyncData {
  project: Project;
  cards: Card[];
  audioSizes: Map<string, number>;
}

interface ReceivedProjectData {
  project: Project;
  cards: Card[];
  audioMap: Map<string, Blob>;
}
```

**Functions:**

`async function gatherProjectForSync(): Promise<ProjectSyncData>`
- Load project: await getProject()
- Load cards: await getAllCards()
- For each card, load audio and record size:
  - const blob = await getAudio(card.id)
  - If blob, audioSizes.set(card.id, blob.size)
- Return { project, cards, audioSizes }

`function cardsToMetadata(cards: Card[], audioSizes: Map<string, number>): CardMetadata[]`
- Map cards to CardMetadata array
- Include audioSize from audioSizes map (0 if not found)

`async function commitReceivedProject(data: ReceivedProjectData): Promise<void>`
- await clearAllData() - clear existing project first
- await saveProject(data.project)
- For each card in data.cards:
  - await saveCard(card)
  - const audio = data.audioMap.get(card.id)
  - If audio: await saveAudio(card.id, audio)

`async function getAudioForCard(cardId: string): Promise<Blob | null>`
- Return await getAudio(cardId)
- Wrapper for convenience in sync flow

**Export all functions.**
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify exports: grep for "export.*gatherProjectForSync" in projectSync.ts.
  </verify>
  <done>
projectSync.ts provides utilities for reading project data for sync and writing received data to IndexedDB.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SyncContext shell and state management</name>
  <files>client/src/contexts/SyncContext.tsx</files>
  <action>
Create new file client/src/contexts/SyncContext.tsx:

**Imports:**
```typescript
import React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';
import { WebRTCConnectionService } from '@/services/webrtc/connection';
import { AudioTransferService } from '@/services/sync/AudioTransferService';
import { gatherProjectForSync, cardsToMetadata, commitReceivedProject, getAudioForCard } from '@/services/sync/projectSync';
import { SyncProgress, SyncRequestMessage, CardMetadata } from '@/types/sync';
import { createSyncRequest, createSyncAccept, createSyncReject, createChunkStart, createChunkComplete, createSyncComplete, createSyncError, isSyncControlMessage } from '@/services/webrtc/syncProtocol';
import type { Card, Project } from '@/types';
// CRITICAL: Import useProject to access dispatch for state reload after sync
import { useProject } from '@/contexts/ProjectContext';
```

**State types:**
```typescript
type SyncRole = 'sender' | 'receiver' | null;

interface SyncState {
  isSyncing: boolean;
  role: SyncRole;
  progress: SyncProgress;
  pendingRequest: SyncRequestMessage | null;
  receivedProject: Project | null;
  receivedCards: Card[];
  receivedAudio: Map<string, Blob>;
}

interface SyncContextValue {
  syncState: SyncState;
  // Sender actions
  startSync: (connection: WebRTCConnectionService) => Promise<void>;
  // Receiver actions
  handleSyncRequest: (request: SyncRequestMessage) => void;
  acceptSync: () => void;
  rejectSync: (reason: string) => void;
  commitSync: () => Promise<void>;
  // Common
  cancelSync: () => void;
  handleControlMessage: (msg: ControlMessage, connection: WebRTCConnectionService) => void;
  handleBinaryMessage: (data: ArrayBuffer) => void;
  // Connection state for auto-sync
  setConnection: (connection: WebRTCConnectionService | null) => void;
  setUserRole: (role: 'editor' | 'viewer') => void;
}
```

**Initial state:**
```typescript
const initialProgress: SyncProgress = {
  phase: 'idle',
  currentCardIndex: 0,
  totalCards: 0,
  currentCardBytesTransferred: 0,
  currentCardBytesTotal: 0,
  totalBytesTransferred: 0,
  totalBytesTotal: 0,
};
```

**SyncProvider component shell:**
- State: syncState with useState, initialized to { isSyncing: false, role: null, progress: initialProgress, pendingRequest: null, receivedProject: null, receivedCards: [], receivedAudio: new Map() }
- Refs: connectionRef, audioTransferRef, userRoleRef
- Get dispatch from useProject: `const { dispatch } = useProject();`

**setConnection function:**
```typescript
const setConnection = useCallback((connection: WebRTCConnectionService | null) => {
  connectionRef.current = connection;
}, []);
```

**setUserRole function:**
```typescript
const setUserRole = useCallback((role: 'editor' | 'viewer') => {
  userRoleRef.current = role;
}, []);
```

**Create context and export SyncProvider and useSync hook.**
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify exports: grep for "export function SyncProvider" and "export function useSync" in SyncContext.tsx.
Check that useProject is imported from @/contexts/ProjectContext.
  </verify>
  <done>
SyncContext shell created with state management, refs for connection tracking, and ProjectContext integration via useProject().
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement sender flow and receiver flow with commitSync</name>
  <files>client/src/contexts/SyncContext.tsx</files>
  <action>
Add to SyncContext.tsx inside SyncProvider:

**startSync (sender flow):**
```typescript
const startSync = useCallback(async (connection: WebRTCConnectionService) => {
  connectionRef.current = connection;

  // 1. Set role='sender', isSyncing=true, phase='requesting'
  setSyncState(prev => ({
    ...prev,
    isSyncing: true,
    role: 'sender',
    progress: { ...initialProgress, phase: 'requesting' },
  }));

  // 2. Gather project
  const { project, cards, audioSizes } = await gatherProjectForSync();

  // 3. Convert to metadata
  const cardMetadata = cardsToMetadata(cards, audioSizes);

  // Calculate total bytes
  let totalBytes = 0;
  audioSizes.forEach(size => totalBytes += size);

  // 4. Create and send request
  const request = createSyncRequest(project, cardMetadata, totalBytes);
  connection.sendControl(request);

  // 5. Set phase='awaiting_accept'
  setSyncState(prev => ({
    ...prev,
    progress: {
      ...prev.progress,
      phase: 'awaiting_accept',
      totalCards: cards.length,
      totalBytesTotal: totalBytes,
    },
  }));

  // 6. Store cards for transfer
  cardsToSendRef.current = cards;
  audioSizesRef.current = audioSizes;
}, []);
```

**handleControlMessage:**
Route by message type using isSyncControlMessage type guard. Handle:
- sync_request: Call handleSyncRequest (store in pendingRequest, receivedProject, receivedCards)
- sync_accept: If sender, call performTransfer()
- sync_reject: Reset state with error
- chunk_start: Prepare for audio chunk
- chunk_complete: Update progress
- sync_complete: Set phase='complete'
- sync_error: Set error state

**handleBinaryMessage (receiver):**
- Pass to audioTransferRef.current.receiveChunk
- When chunk complete, store blob in receivedAudio map
- Update progress

**performTransfer (sender, internal):**
```typescript
async function performTransfer() {
  const cards = cardsToSendRef.current;
  const audioSizes = audioSizesRef.current;
  const connection = connectionRef.current;
  if (!connection || !cards) return;

  audioTransferRef.current = new AudioTransferService(connection);

  setSyncState(prev => ({
    ...prev,
    progress: { ...prev.progress, phase: 'transferring' },
  }));

  for (let i = 0; i < cards.length; i++) {
    const card = cards[i];
    const audio = await getAudioForCard(card.id);
    if (!audio) continue;

    // Send chunk_start
    connection.sendControl(createChunkStart(card.id, i, Math.ceil(audio.size / 16384), audio.size));

    // Send audio chunks
    await audioTransferRef.current.sendAudio(card.id, i, audio, (chunkProgress) => {
      setSyncState(prev => ({
        ...prev,
        progress: {
          ...prev.progress,
          currentCardIndex: i,
          currentCardBytesTransferred: chunkProgress.bytesTransferred,
          currentCardBytesTotal: audio.size,
          totalBytesTransferred: prev.progress.totalBytesTransferred + chunkProgress.bytesTransferred,
        },
      }));
    });

    // Send chunk_complete
    connection.sendControl(createChunkComplete(card.id, i));
  }

  // Send sync_complete
  const totalBytes = Array.from(audioSizes.values()).reduce((a, b) => a + b, 0);
  connection.sendControl(createSyncComplete(cards.length, totalBytes));

  setSyncState(prev => ({
    ...prev,
    progress: { ...prev.progress, phase: 'complete' },
  }));
}
```

**acceptSync (receiver):**
- Send createSyncAccept() via connection
- Set phase='transferring'

**rejectSync (receiver):**
- Send createSyncReject(reason)
- Reset state

**commitSync (receiver) - CRITICAL integration with ProjectContext:**
```typescript
const commitSync = useCallback(async () => {
  const { receivedProject, receivedCards, receivedAudio } = syncState;

  if (!receivedProject || receivedCards.length === 0) {
    console.error('No received data to commit');
    return;
  }

  // 1. Commit to IndexedDB
  await commitReceivedProject({
    project: receivedProject,
    cards: receivedCards,
    audioMap: receivedAudio,
  });

  // 2. CRITICAL: Reload ProjectContext state via dispatch
  // Import dispatch from useProject() at top of SyncProvider
  // The INIT_STATE action accepts { cards, project } and updates AppState
  dispatch({
    type: 'INIT_STATE',
    payload: {
      cards: receivedCards,
      project: receivedProject,
    },
  });

  // 3. Reset sync state
  setSyncState({
    isSyncing: false,
    role: null,
    progress: initialProgress,
    pendingRequest: null,
    receivedProject: null,
    receivedCards: [],
    receivedAudio: new Map(),
  });
}, [syncState, dispatch]);
```

**cancelSync:**
- Reset state
- If mid-transfer, send createSyncError('User cancelled')
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify commitSync calls dispatch with INIT_STATE: grep for "dispatch.*INIT_STATE" in SyncContext.tsx.
Verify useProject import: grep for "import.*useProject.*from.*ProjectContext" in SyncContext.tsx.
Check ProjectContext.tsx exports dispatch and accepts INIT_STATE action (already confirmed: dispatch is in ProjectContextValue, INIT_STATE is an Action type).
  </verify>
  <done>
SyncContext implements full sender flow (startSync -> performTransfer) and receiver flow (handleSyncRequest -> acceptSync -> commitSync). commitSync properly integrates with ProjectContext by calling dispatch({ type: 'INIT_STATE', payload: { cards, project } }) to reload UI state after IndexedDB commit.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add auto-sync on connection (XFER-01)</name>
  <files>client/src/contexts/SyncContext.tsx</files>
  <action>
Add useEffect inside SyncProvider that triggers auto-sync when connection established:

```typescript
// Track connection state for auto-sync trigger
const [connectionState, setConnectionState] = useState<'disconnected' | 'connected'>('disconnected');

// Auto-sync effect: When editor connects, automatically start sync (XFER-01)
useEffect(() => {
  // Only auto-sync if:
  // 1. Connection just became 'connected'
  // 2. User role is 'editor'
  // 3. Not already syncing
  // 4. Connection ref is valid
  if (
    connectionState === 'connected' &&
    userRoleRef.current === 'editor' &&
    !syncState.isSyncing &&
    connectionRef.current
  ) {
    // Small delay to ensure connection is stable
    const timer = setTimeout(() => {
      if (connectionRef.current) {
        startSync(connectionRef.current);
      }
    }, 500);

    return () => clearTimeout(timer);
  }
}, [connectionState, syncState.isSyncing, startSync]);

// Update setConnection to also track state
const setConnection = useCallback((connection: WebRTCConnectionService | null) => {
  connectionRef.current = connection;
  setConnectionState(connection ? 'connected' : 'disconnected');
}, []);
```

**Update SyncContextValue to include setConnection and setUserRole.**

**Usage note in comments:**
The Header or connection dialog component should call:
- `setConnection(connection)` when WebRTC connection established
- `setUserRole('editor')` or `setUserRole('viewer')` based on who initiated

This ensures XFER-01 ("When connected, editor's full project transfers to viewer automatically") is satisfied without requiring manual "Sync Project" button click.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify auto-sync effect exists: grep for "Auto-sync effect" or "connectionState === 'connected'" in SyncContext.tsx.
  </verify>
  <done>
Auto-sync implemented: When connection transitions to 'connected' and user role is 'editor', startSync is triggered automatically after 500ms delay. This satisfies XFER-01 requirement for automatic transfer on connection.
  </done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] projectSync.ts exports gatherProjectForSync, cardsToMetadata, commitReceivedProject
- [ ] SyncContext.tsx exports SyncProvider and useSync
- [ ] SyncContext imports useProject from @/contexts/ProjectContext
- [ ] commitSync calls dispatch({ type: 'INIT_STATE', payload: { cards, project } })
- [ ] Auto-sync useEffect triggers startSync when connection='connected' and role='editor'
- [ ] SyncProvider handles all sync control message types
- [ ] Sender flow: startSync -> awaiting_accept -> transferring -> complete
- [ ] Receiver flow: sync_request -> accept -> transferring -> complete -> commit
</verification>

<success_criteria>
- projectSync can gather full project data including audio sizes
- projectSync can commit received project to IndexedDB (clears existing first)
- SyncContext provides complete sync orchestration
- Progress state updates as chunks transfer
- Received audio stored in memory until commit
- commitSync integrates with ProjectContext via dispatch({ type: 'INIT_STATE' }) for UI reload
- Auto-sync triggers when editor connects (XFER-01 satisfied)
</success_criteria>

<output>
After completion, create `.planning/phases/02-initial-sync/02-03-SUMMARY.md`
</output>
