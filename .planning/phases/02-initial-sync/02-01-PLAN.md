---
phase: 02-initial-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/types/sync.ts
  - client/src/services/webrtc/syncProtocol.ts
autonomous: true

must_haves:
  truths:
    - "Sync protocol messages have well-defined TypeScript types"
    - "Control messages can be parsed and routed by type"
    - "Binary chunk headers can be encoded and decoded correctly"
  artifacts:
    - path: "client/src/types/sync.ts"
      provides: "Sync message type definitions"
      contains: "SyncRequestMessage"
    - path: "client/src/services/webrtc/syncProtocol.ts"
      provides: "Protocol message handlers and routing"
      exports: ["createSyncRequest", "parseBinaryChunk", "createBinaryChunk"]
  key_links:
    - from: "client/src/services/webrtc/syncProtocol.ts"
      to: "client/src/types/sync.ts"
      via: "import"
      pattern: "import.*from.*@/types/sync"
---

<objective>
Define TypeScript types for the initial sync protocol and create message handlers for the metadata-first sync flow.

Purpose: Establish the type-safe foundation for all sync communication. Without well-defined message types, the sync protocol cannot be implemented reliably.

Output: Extended sync.ts with transfer message types, new syncProtocol.ts with message creation/parsing utilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-initial-sync/02-RESEARCH.md
@client/src/types/sync.ts
@client/src/types/index.ts
@client/src/services/webrtc/connection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend sync.ts with transfer message types</name>
  <files>client/src/types/sync.ts</files>
  <action>
Add the following types to sync.ts, building on existing ControlMessage:

1. **SyncRequestMessage** - Editor sends to viewer on connection:
   - type: 'sync_request'
   - project: { createdAt: string; updatedAt: string }
   - cards: Array of card metadata (id, label, notes, tags, color, duration, waveformData?, transcript?, createdAt, updatedAt, order, audioSize)
   - totalAudioBytes: number

2. **SyncAcceptMessage** - Viewer accepts sync:
   - type: 'sync_accept'

3. **SyncRejectMessage** - Viewer rejects sync:
   - type: 'sync_reject'
   - reason: string

4. **ChunkStartMessage** - Before sending audio for a card:
   - type: 'chunk_start'
   - cardId: string
   - cardIndex: number
   - totalChunks: number
   - audioSize: number

5. **ChunkCompleteMessage** - After all chunks for a card sent:
   - type: 'chunk_complete'
   - cardId: string
   - cardIndex: number

6. **SyncCompleteMessage** - All cards transferred:
   - type: 'sync_complete'
   - totalCards: number
   - totalBytes: number

7. **SyncErrorMessage** - Error during sync:
   - type: 'sync_error'
   - error: string

8. **SyncControlMessage** - Union type of all sync messages for type narrowing

9. **SyncProgress** interface for tracking transfer state:
   - phase: 'idle' | 'requesting' | 'awaiting_accept' | 'transferring' | 'complete' | 'error'
   - currentCardIndex: number
   - totalCards: number
   - currentCardBytesTransferred: number
   - currentCardBytesTotal: number
   - totalBytesTransferred: number
   - totalBytesTotal: number
   - error?: string

10. **CardMetadata** type for card data without audio (used in sync_request)

Import Card and CardColor from @/types to ensure type compatibility.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify types are exported: grep for "export type SyncRequestMessage" in sync.ts.
  </verify>
  <done>
All 10 types defined and exported. SyncControlMessage union enables type narrowing on message.type.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create syncProtocol.ts with message utilities</name>
  <files>client/src/services/webrtc/syncProtocol.ts</files>
  <action>
Create new file with these exports:

1. **Constants:**
   - CHUNK_SIZE = 16 * 1024 (16KB)
   - CHUNK_HEADER_SIZE = 8 (4 bytes cardIndex + 4 bytes chunkIndex)
   - BUFFER_THRESHOLD = 64 * 1024 (64KB for backpressure)

2. **Message creators** (return Omit<MessageType, 'timestamp' | 'id'>):
   - createSyncRequest(project, cards, audioSizes: Map<string, number>): creates sync_request with calculated totalAudioBytes
   - createSyncAccept(): creates sync_accept
   - createSyncReject(reason): creates sync_reject
   - createChunkStart(cardId, cardIndex, totalChunks, audioSize): creates chunk_start
   - createChunkComplete(cardId, cardIndex): creates chunk_complete
   - createSyncComplete(totalCards, totalBytes): creates sync_complete
   - createSyncError(error): creates sync_error

3. **Binary chunk utilities:**
   - createBinaryChunk(cardIndex: number, chunkIndex: number, data: ArrayBuffer): ArrayBuffer
     Creates chunk with header: [cardIndex:4 bytes LE][chunkIndex:4 bytes LE][data]

   - parseBinaryChunk(data: ArrayBuffer): { cardIndex: number; chunkIndex: number; chunkData: ArrayBuffer }
     Parses header and returns components

4. **Chunk calculation:**
   - calculateTotalChunks(audioSize: number): number
     Returns Math.ceil(audioSize / CHUNK_SIZE)

5. **Type guard:**
   - isSyncControlMessage(msg: ControlMessage): msg is SyncControlMessage
     Checks if msg.type is one of the sync message types

Use DataView for binary header encoding/decoding (little-endian for consistency).
Import types from @/types/sync.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Test binary chunk round-trip: create chunk with createBinaryChunk, parse with parseBinaryChunk, verify data matches.
  </verify>
  <done>
syncProtocol.ts exports all message creators, binary utilities, and type guard. Constants defined for consistent chunk sizing.
  </done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] sync.ts exports SyncRequestMessage, SyncControlMessage, SyncProgress, CardMetadata
- [ ] syncProtocol.ts exports createSyncRequest, createBinaryChunk, parseBinaryChunk
- [ ] Binary chunk header correctly encodes/decodes cardIndex and chunkIndex
- [ ] Constants CHUNK_SIZE=16384, BUFFER_THRESHOLD=65536 defined
</verification>

<success_criteria>
- All sync protocol types defined with proper TypeScript discriminated unions
- Message creators provide type-safe message construction
- Binary chunk utilities correctly encode/decode 8-byte headers
- No runtime dependencies added (browser APIs only)
</success_criteria>

<output>
After completion, create `.planning/phases/02-initial-sync/02-01-SUMMARY.md`
</output>
