---
phase: 01-webrtc-connection
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - client/src/hooks/useWebRTC.ts
  - client/src/components/ConnectionDialog.tsx
  - client/src/components/SyncIndicator.tsx
  - client/src/components/Header.tsx
  - client/src/pages/Home.tsx
autonomous: false

must_haves:
  truths:
    - "User can click Connect button in header to open connection dialog"
    - "User can generate offer code by clicking 'Start Connection'"
    - "User can paste received offer code to create answer"
    - "User can copy their code to clipboard with visual feedback"
    - "User sees connection status indicator at all times"
    - "Connected state shows green indicator, error shows red"
  artifacts:
    - path: "client/src/hooks/useWebRTC.ts"
      provides: "React hook wrapping WebRTCConnectionService"
      exports: ["useWebRTC"]
    - path: "client/src/components/ConnectionDialog.tsx"
      provides: "Step-by-step SDP exchange UI"
      exports: ["ConnectionDialog"]
      min_lines: 100
    - path: "client/src/components/SyncIndicator.tsx"
      provides: "Connection status badge"
      exports: ["SyncIndicator"]
    - path: "client/src/components/Header.tsx"
      provides: "Header with Connect button and status indicator"
      contains: "SyncIndicator"
    - path: "client/src/pages/Home.tsx"
      provides: "Main page wiring useWebRTC hook and ConnectionDialog"
      contains: "useWebRTC"
  key_links:
    - from: "client/src/hooks/useWebRTC.ts"
      to: "client/src/services/webrtc/connection.ts"
      via: "WebRTCConnectionService instance"
      pattern: "new WebRTCConnectionService"
    - from: "client/src/components/ConnectionDialog.tsx"
      to: "client/src/hooks/useWebRTC.ts"
      via: "useWebRTC hook"
      pattern: "useWebRTC"
    - from: "client/src/components/Header.tsx"
      to: "client/src/components/SyncIndicator.tsx"
      via: "component import"
      pattern: "SyncIndicator"
    - from: "client/src/pages/Home.tsx"
      to: "client/src/hooks/useWebRTC.ts"
      via: "hook invocation"
      pattern: "const .* = useWebRTC\\(\\)"
    - from: "client/src/pages/Home.tsx"
      to: "client/src/components/ConnectionDialog.tsx"
      via: "component render"
      pattern: "<ConnectionDialog"
    - from: "client/src/pages/Home.tsx"
      to: "client/src/components/Header.tsx"
      via: "connectionState prop"
      pattern: "connectionState=.*onConnectClick="
---

<objective>
Create the React hook and UI components for P2P connection: useWebRTC hook, ConnectionDialog for code exchange, SyncIndicator for status display, and integrate into Header and Home.tsx.

Purpose: Enable users to establish P2P connections through a guided, visual flow with clear status feedback throughout.

Output: Working connection UI accessible from Header, with step-by-step code exchange and persistent status indicator.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-webrtc-connection/01-01-SUMMARY.md
@.planning/phases/01-webrtc-connection/01-02-SUMMARY.md
@client/src/services/webrtc/connection.ts
@client/src/types/sync.ts
@client/src/components/Header.tsx
@client/src/pages/Home.tsx
@client/src/components/ui/dialog.tsx
@client/src/components/ui/button.tsx
@client/src/components/ui/input.tsx
@client/src/components/ui/badge.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useWebRTC hook</name>
  <files>client/src/hooks/useWebRTC.ts</files>
  <action>
Create a React hook that wraps WebRTCConnectionService:

```typescript
import { useState, useCallback, useRef, useEffect } from 'react';
import { WebRTCConnectionService } from '@/services/webrtc/connection';
import type { ConnectionState, ControlMessage } from '@/types/sync';

interface UseWebRTCReturn {
  state: ConnectionState;
  offerCode: string | null;
  answerCode: string | null;
  error: string | null;

  createOffer: () => Promise<void>;
  acceptOffer: (code: string) => Promise<void>;
  acceptAnswer: (code: string) => Promise<void>;
  disconnect: () => void;

  sendControl: (msg: Omit<ControlMessage, 'timestamp' | 'id'>) => boolean;
  sendBinary: (data: ArrayBuffer) => boolean;

  // Callbacks for message handling (set by consumer)
  setOnControlMessage: (handler: (msg: ControlMessage) => void) => void;
  setOnBinaryMessage: (handler: (data: ArrayBuffer) => void) => void;
}

export function useWebRTC(): UseWebRTCReturn {
  const serviceRef = useRef<WebRTCConnectionService | null>(null);
  const [state, setState] = useState<ConnectionState>('disconnected');
  const [offerCode, setOfferCode] = useState<string | null>(null);
  const [answerCode, setAnswerCode] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Lazily initialize service
  const getService = useCallback(() => {
    if (!serviceRef.current) {
      serviceRef.current = new WebRTCConnectionService();
      serviceRef.current.setCallbacks({
        onStateChange: (newState) => {
          setState(newState);
          if (newState === 'error') {
            setError('Connection failed');
          }
        },
      });
    }
    return serviceRef.current;
  }, []);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      serviceRef.current?.disconnect();
    };
  }, []);

  const createOffer = useCallback(async () => {
    setError(null);
    setOfferCode(null);
    const service = getService();
    const result = await service.createOffer();
    if (result.success) {
      setOfferCode(result.data);
    } else {
      setError(result.error);
    }
  }, [getService]);

  const acceptOffer = useCallback(async (code: string) => {
    setError(null);
    setAnswerCode(null);
    const service = getService();
    const result = await service.acceptOffer(code);
    if (result.success) {
      setAnswerCode(result.data);
    } else {
      setError(result.error);
    }
  }, [getService]);

  const acceptAnswer = useCallback(async (code: string) => {
    setError(null);
    const service = getService();
    const result = await service.acceptAnswer(code);
    if (!result.success) {
      setError(result.error);
    }
  }, [getService]);

  const disconnect = useCallback(() => {
    serviceRef.current?.disconnect();
    setOfferCode(null);
    setAnswerCode(null);
    setError(null);
  }, []);

  const sendControl = useCallback((msg: Omit<ControlMessage, 'timestamp' | 'id'>) => {
    return serviceRef.current?.sendControl(msg) ?? false;
  }, []);

  const sendBinary = useCallback((data: ArrayBuffer) => {
    return serviceRef.current?.sendBinary(data) ?? false;
  }, []);

  const setOnControlMessage = useCallback((handler: (msg: ControlMessage) => void) => {
    getService().setCallbacks({ onControlMessage: handler });
  }, [getService]);

  const setOnBinaryMessage = useCallback((handler: (data: ArrayBuffer) => void) => {
    getService().setCallbacks({ onBinaryMessage: handler });
  }, [getService]);

  return {
    state,
    offerCode,
    answerCode,
    error,
    createOffer,
    acceptOffer,
    acceptAnswer,
    disconnect,
    sendControl,
    sendBinary,
    setOnControlMessage,
    setOnBinaryMessage,
  };
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
  </verify>
  <done>
useWebRTC hook exports from hooks/useWebRTC.ts, wraps service with React state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SyncIndicator component</name>
  <files>client/src/components/SyncIndicator.tsx</files>
  <action>
Create a badge-style component showing connection status:

```typescript
import { Badge } from '@/components/ui/badge';
import { Wifi, WifiOff, Loader2, AlertCircle } from 'lucide-react';
import type { ConnectionState } from '@/types/sync';

interface SyncIndicatorProps {
  state: ConnectionState;
  onClick?: () => void;
}

export function SyncIndicator({ state, onClick }: SyncIndicatorProps) {
  const config = getStateConfig(state);

  return (
    <Badge
      variant={config.variant}
      className={`cursor-pointer gap-1.5 ${config.className}`}
      onClick={onClick}
    >
      {config.icon}
      <span className="hidden sm:inline">{config.label}</span>
    </Badge>
  );
}

function getStateConfig(state: ConnectionState) {
  switch (state) {
    case 'connected':
      return {
        variant: 'default' as const,
        className: 'bg-green-500/10 text-green-600 hover:bg-green-500/20 border-green-500/30',
        icon: <Wifi className="w-3.5 h-3.5" />,
        label: 'Connected',
      };
    case 'connecting':
    case 'creating_offer':
    case 'awaiting_answer':
    case 'creating_answer':
      return {
        variant: 'secondary' as const,
        className: 'bg-yellow-500/10 text-yellow-600 hover:bg-yellow-500/20 border-yellow-500/30',
        icon: <Loader2 className="w-3.5 h-3.5 animate-spin" />,
        label: 'Connecting',
      };
    case 'error':
      return {
        variant: 'destructive' as const,
        className: 'bg-red-500/10 text-red-600 hover:bg-red-500/20 border-red-500/30',
        icon: <AlertCircle className="w-3.5 h-3.5" />,
        label: 'Error',
      };
    case 'disconnected':
    default:
      return {
        variant: 'outline' as const,
        className: 'text-muted-foreground hover:bg-muted',
        icon: <WifiOff className="w-3.5 h-3.5" />,
        label: 'Offline',
      };
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
  </verify>
  <done>
SyncIndicator renders appropriate icon/color/label for each connection state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ConnectionDialog component</name>
  <files>client/src/components/ConnectionDialog.tsx</files>
  <action>
Create a multi-step dialog for SDP exchange:

```typescript
import { useState, useEffect } from 'react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Copy, Check, Loader2 } from 'lucide-react';
import { toast } from 'sonner';
import type { ConnectionState } from '@/types/sync';

type DialogStep = 'choose' | 'create-offer' | 'enter-offer' | 'show-answer' | 'enter-answer' | 'connecting' | 'connected';

interface ConnectionDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  state: ConnectionState;
  offerCode: string | null;
  answerCode: string | null;
  error: string | null;
  onCreateOffer: () => Promise<void>;
  onAcceptOffer: (code: string) => Promise<void>;
  onAcceptAnswer: (code: string) => Promise<void>;
  onDisconnect: () => void;
}

export function ConnectionDialog({
  open,
  onOpenChange,
  state,
  offerCode,
  answerCode,
  error,
  onCreateOffer,
  onAcceptOffer,
  onAcceptAnswer,
  onDisconnect,
}: ConnectionDialogProps) {
  const [step, setStep] = useState<DialogStep>('choose');
  const [inputCode, setInputCode] = useState('');
  const [copied, setCopied] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  // Reset state when dialog opens
  useEffect(() => {
    if (open) {
      if (state === 'connected') {
        setStep('connected');
      } else {
        setStep('choose');
        setInputCode('');
        setCopied(false);
      }
    }
  }, [open, state]);

  // Update step based on connection state
  useEffect(() => {
    if (state === 'connected') {
      setStep('connected');
      setIsLoading(false);
    } else if (state === 'connecting') {
      setStep('connecting');
    }
  }, [state]);

  const copyToClipboard = async (text: string) => {
    await navigator.clipboard.writeText(text);
    setCopied(true);
    toast.success('Code copied to clipboard');
    setTimeout(() => setCopied(false), 2000);
  };

  const handleStartConnection = async () => {
    setIsLoading(true);
    await onCreateOffer();
    setIsLoading(false);
    setStep('create-offer');
  };

  const handleJoinConnection = () => {
    setStep('enter-offer');
  };

  const handleSubmitOffer = async () => {
    if (!inputCode.trim()) return;
    setIsLoading(true);
    await onAcceptOffer(inputCode.trim());
    setIsLoading(false);
    if (!error) {
      setStep('show-answer');
      setInputCode('');
    }
  };

  const handleSubmitAnswer = async () => {
    if (!inputCode.trim()) return;
    setIsLoading(true);
    await onAcceptAnswer(inputCode.trim());
    setIsLoading(false);
    // Will transition to 'connecting' then 'connected' via state
  };

  const handleDisconnect = () => {
    onDisconnect();
    setStep('choose');
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-md">
        {/* Step: Choose role */}
        {step === 'choose' && (
          <>
            <DialogHeader>
              <DialogTitle>Connect to Peer</DialogTitle>
              <DialogDescription>
                Connect with another device to sync your project in real-time.
              </DialogDescription>
            </DialogHeader>
            <div className="flex flex-col gap-3 py-4">
              <Button onClick={handleStartConnection} disabled={isLoading}>
                {isLoading ? <Loader2 className="w-4 h-4 mr-2 animate-spin" /> : null}
                Start Connection
              </Button>
              <Button variant="outline" onClick={handleJoinConnection}>
                Join with Code
              </Button>
            </div>
            <DialogDescription className="text-xs text-center">
              One person starts the connection, the other joins with the code.
            </DialogDescription>
          </>
        )}

        {/* Step: Show offer code */}
        {step === 'create-offer' && (
          <>
            <DialogHeader>
              <DialogTitle>Share Your Code</DialogTitle>
              <DialogDescription>
                Send this code to your peer. They will send back their code.
              </DialogDescription>
            </DialogHeader>
            <div className="py-4 space-y-3">
              <div className="relative">
                <Textarea
                  value={offerCode || ''}
                  readOnly
                  className="font-mono text-xs h-24 resize-none pr-12"
                />
                <Button
                  size="icon"
                  variant="ghost"
                  className="absolute top-2 right-2"
                  onClick={() => offerCode && copyToClipboard(offerCode)}
                >
                  {copied ? <Check className="w-4 h-4" /> : <Copy className="w-4 h-4" />}
                </Button>
              </div>
              {error && <p className="text-sm text-destructive">{error}</p>}
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setStep('enter-answer')}>
                I have their code
              </Button>
            </DialogFooter>
          </>
        )}

        {/* Step: Enter offer code */}
        {step === 'enter-offer' && (
          <>
            <DialogHeader>
              <DialogTitle>Enter Connection Code</DialogTitle>
              <DialogDescription>
                Paste the code you received from your peer.
              </DialogDescription>
            </DialogHeader>
            <div className="py-4 space-y-3">
              <Textarea
                value={inputCode}
                onChange={(e) => setInputCode(e.target.value)}
                placeholder="Paste connection code here..."
                className="font-mono text-xs h-24 resize-none"
              />
              {error && <p className="text-sm text-destructive">{error}</p>}
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setStep('choose')}>
                Back
              </Button>
              <Button onClick={handleSubmitOffer} disabled={!inputCode.trim() || isLoading}>
                {isLoading ? <Loader2 className="w-4 h-4 mr-2 animate-spin" /> : null}
                Continue
              </Button>
            </DialogFooter>
          </>
        )}

        {/* Step: Show answer code */}
        {step === 'show-answer' && (
          <>
            <DialogHeader>
              <DialogTitle>Send Your Code Back</DialogTitle>
              <DialogDescription>
                Send this code back to complete the connection.
              </DialogDescription>
            </DialogHeader>
            <div className="py-4 space-y-3">
              <div className="relative">
                <Textarea
                  value={answerCode || ''}
                  readOnly
                  className="font-mono text-xs h-24 resize-none pr-12"
                />
                <Button
                  size="icon"
                  variant="ghost"
                  className="absolute top-2 right-2"
                  onClick={() => answerCode && copyToClipboard(answerCode)}
                >
                  {copied ? <Check className="w-4 h-4" /> : <Copy className="w-4 h-4" />}
                </Button>
              </div>
            </div>
            <DialogDescription className="text-xs">
              Connection will establish automatically once your peer enters this code.
            </DialogDescription>
          </>
        )}

        {/* Step: Enter answer code (initiator) */}
        {step === 'enter-answer' && (
          <>
            <DialogHeader>
              <DialogTitle>Enter Response Code</DialogTitle>
              <DialogDescription>
                Paste the code your peer sent back.
              </DialogDescription>
            </DialogHeader>
            <div className="py-4 space-y-3">
              <Textarea
                value={inputCode}
                onChange={(e) => setInputCode(e.target.value)}
                placeholder="Paste response code here..."
                className="font-mono text-xs h-24 resize-none"
              />
              {error && <p className="text-sm text-destructive">{error}</p>}
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setStep('create-offer')}>
                Back
              </Button>
              <Button onClick={handleSubmitAnswer} disabled={!inputCode.trim() || isLoading}>
                {isLoading ? <Loader2 className="w-4 h-4 mr-2 animate-spin" /> : null}
                Connect
              </Button>
            </DialogFooter>
          </>
        )}

        {/* Step: Connecting */}
        {step === 'connecting' && (
          <>
            <DialogHeader>
              <DialogTitle>Connecting...</DialogTitle>
            </DialogHeader>
            <div className="py-8 flex flex-col items-center gap-4">
              <Loader2 className="w-8 h-8 animate-spin text-primary" />
              <p className="text-sm text-muted-foreground">
                Establishing peer connection...
              </p>
            </div>
          </>
        )}

        {/* Step: Connected */}
        {step === 'connected' && (
          <>
            <DialogHeader>
              <DialogTitle>Connected!</DialogTitle>
              <DialogDescription>
                You are now connected to your peer.
              </DialogDescription>
            </DialogHeader>
            <div className="py-4 flex justify-center">
              <div className="w-16 h-16 rounded-full bg-green-500/10 flex items-center justify-center">
                <Check className="w-8 h-8 text-green-500" />
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => onOpenChange(false)}>
                Close
              </Button>
              <Button variant="destructive" onClick={handleDisconnect}>
                Disconnect
              </Button>
            </DialogFooter>
          </>
        )}
      </DialogContent>
    </Dialog>
  );
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
  </verify>
  <done>
ConnectionDialog handles full flow: choose role, show/enter codes, connecting, connected states.
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate into Header</name>
  <files>client/src/components/Header.tsx</files>
  <action>
Update Header.tsx to include the SyncIndicator and Connect functionality:

1. Add new props to HeaderProps:
   ```typescript
   connectionState: ConnectionState;
   onConnectClick: () => void;
   ```

2. Add import for SyncIndicator:
   ```typescript
   import { SyncIndicator } from './SyncIndicator';
   import type { ConnectionState } from '@/types/sync';
   ```

3. Update component signature to accept new props:
   ```typescript
   export function Header({
     searchQuery,
     onSearchChange,
     onExport,
     onImport,
     onClearProject,
     onExportAudio,
     canUndo,
     canRedo,
     onUndo,
     onRedo,
     connectionState,
     onConnectClick,
   }: HeaderProps)
   ```

4. Add SyncIndicator in the actions area, BEFORE the theme toggle:
   ```tsx
   {/* Actions */}
   <div className="flex items-center gap-2 shrink-0">
     {/* Sync indicator */}
     <SyncIndicator state={connectionState} onClick={onConnectClick} />

     {/* Undo/Redo buttons */}
     ...existing code...
   ```

This places the connection status prominently in the header where users will see it at all times.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors (will error until Home.tsx is updated, that's expected).
  </verify>
  <done>
Header accepts connectionState and onConnectClick props, renders SyncIndicator.
  </done>
</task>

<task type="auto">
  <name>Task 5: Integrate into Home.tsx</name>
  <files>client/src/pages/Home.tsx</files>
  <action>
Update Home.tsx to wire up the useWebRTC hook, ConnectionDialog, and pass props to Header:

1. Add imports at top of file:
   ```typescript
   import { useWebRTC } from '@/hooks/useWebRTC';
   import { ConnectionDialog } from '@/components/ConnectionDialog';
   ```

2. Inside the Home component, add state for dialog open and call the hook:
   ```typescript
   // WebRTC connection state
   const [connectionDialogOpen, setConnectionDialogOpen] = useState(false);
   const webrtc = useWebRTC();
   ```

3. Update the Header component render (around line 1097) to pass the new props:
   ```tsx
   <Header
     searchQuery={state.ui.searchQuery}
     onSearchChange={(query) => dispatch({ type: 'SET_UI', payload: { searchQuery: query } })}
     onExport={handleExport}
     onImport={handleImport}
     onClearProject={handleClearProject}
     onExportAudio={state.cards.length > 0 ? handleExportAudio : undefined}
     canUndo={canUndo}
     canRedo={canRedo}
     onUndo={undo}
     onRedo={redo}
     connectionState={webrtc.state}
     onConnectClick={() => setConnectionDialogOpen(true)}
   />
   ```

4. Add ConnectionDialog render inside the return statement, after the AudioTrimmer component (around line 1234):
   ```tsx
   <ConnectionDialog
     open={connectionDialogOpen}
     onOpenChange={setConnectionDialogOpen}
     state={webrtc.state}
     offerCode={webrtc.offerCode}
     answerCode={webrtc.answerCode}
     error={webrtc.error}
     onCreateOffer={webrtc.createOffer}
     onAcceptOffer={webrtc.acceptOffer}
     onAcceptAnswer={webrtc.acceptAnswer}
     onDisconnect={webrtc.disconnect}
   />
   ```

This completes the wiring: Header shows status and opens dialog on click, dialog uses hook for all WebRTC operations.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors. All components properly wired.
  </verify>
  <done>
Home.tsx imports useWebRTC hook and ConnectionDialog, passes connectionState/onConnectClick to Header, renders ConnectionDialog with all webrtc props.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Full connection UI: useWebRTC hook, SyncIndicator, ConnectionDialog, Header integration, Home.tsx wiring.
  </what-built>
  <how-to-verify>
1. Run `pnpm dev` to start the development server
2. Open http://localhost:5173 (or the dev URL shown)
3. Verify you see a status indicator in the header (shows "Offline" with icon)
4. Click the indicator - ConnectionDialog should open
5. Click "Start Connection" - should show a long code after a few seconds
6. Copy the code - verify toast says "Code copied"
7. Open a second browser tab with the same URL
8. In tab 2: Click indicator, click "Join with Code"
9. Paste the code from tab 1, click Continue
10. Tab 2 should show their answer code - copy it
11. In tab 1: Click "I have their code", paste tab 2's code, click Connect
12. Both tabs should show "Connected!" with green indicator
13. Close dialogs - both headers should show green "Connected" indicator
14. Click either indicator - should show connected state with Disconnect option
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- useWebRTC hook wraps service and manages React state
- SyncIndicator shows correct icon/color for each state
- ConnectionDialog guides user through complete flow
- Header shows connection status at all times
- Home.tsx wires hook to Header and renders ConnectionDialog
- Two browser tabs can establish P2P connection via code exchange
</verification>

<success_criteria>
- CONN-01: User can click "Start Connection" and see shareable code
- CONN-02: User can paste received code to join
- CONN-03: Joining user gets answer code to send back
- CONN-04: After code exchange, connection establishes (green indicator)
- CONN-05: User sees status indicator at all times (header badge)
</success_criteria>

<output>
After completion, create `.planning/phases/01-webrtc-connection/01-03-SUMMARY.md`
</output>
