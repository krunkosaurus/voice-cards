---
phase: 01-webrtc-connection
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - client/src/services/webrtc/connection.ts
autonomous: true

must_haves:
  truths:
    - "RTCPeerConnection can be created with configured ICE servers"
    - "Offer can be generated and ICE gathering completes before returning"
    - "Answer can be generated from received offer"
    - "Dual DataChannels (control + binary) are created and opened"
    - "Connection state transitions are trackable via callback"
  artifacts:
    - path: "client/src/services/webrtc/connection.ts"
      provides: "WebRTCConnectionService class managing RTCPeerConnection lifecycle"
      exports: ["WebRTCConnectionService"]
      min_lines: 150
  key_links:
    - from: "client/src/services/webrtc/connection.ts"
      to: "client/src/types/sync.ts"
      via: "import ConnectionState, ConnectionConfig"
      pattern: "import.*from.*sync"
    - from: "client/src/services/webrtc/connection.ts"
      to: "client/src/services/webrtc/sdpCodec.ts"
      via: "import encodeSDP, decodeSDP"
      pattern: "import.*from.*sdpCodec"
---

<objective>
Implement the WebRTCConnectionService class that manages the RTCPeerConnection lifecycle, including offer/answer generation with ICE gathering and dual DataChannel setup.

Purpose: Core connection layer that handles all WebRTC complexity, exposing a clean API for offer/answer exchange and state tracking.

Output: WebRTCConnectionService in connection.ts with full connection lifecycle management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-webrtc-connection/01-01-SUMMARY.md
@client/src/types/sync.ts
@client/src/services/webrtc/sdpCodec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WebRTCConnectionService core</name>
  <files>client/src/services/webrtc/connection.ts</files>
  <action>
Create WebRTCConnectionService class with:

**Private properties:**
- `pc: RTCPeerConnection | null` - The peer connection
- `controlChannel: RTCDataChannel | null` - For metadata/control messages
- `binaryChannel: RTCDataChannel | null` - For audio blob chunks
- `state: ConnectionState` - Current connection state
- `role: ConnectionRole | null` - Initiator or responder
- `config: ConnectionConfig` - ICE servers and timeouts
- `onStateChange: ((state: ConnectionState) => void) | null` - State callback
- `onControlMessage: ((msg: ControlMessage) => void) | null` - Message callback
- `onBinaryMessage: ((data: ArrayBuffer) => void) | null` - Binary callback

**Constructor:**
```typescript
constructor(config?: Partial<ConnectionConfig>)
```
- Merge provided config with defaults (DEFAULT_ICE_SERVERS, 10s timeout)
- Initialize state to 'disconnected'

**Public methods:**

1. `setCallbacks(callbacks: { onStateChange?, onControlMessage?, onBinaryMessage? })`
   - Store callback functions for external notification

2. `async createOffer(): Promise<SDPCodecResult<string>>`
   - Set state to 'creating_offer', set role to 'initiator'
   - Create RTCPeerConnection with iceServers config
   - Create both DataChannels:
     - control: `{ ordered: true, maxRetransmits: 5 }`
     - binary: `{ ordered: true }`
   - Set up DataChannel event handlers (onopen, onmessage, onerror, onclose)
   - Create offer: `await pc.createOffer()`
   - Set local description: `await pc.setLocalDescription(offer)`
   - Wait for ICE gathering complete (see helper below)
   - Encode final SDP with sdpCodec.encodeSDP
   - Set state to 'awaiting_answer'
   - Return encoded offer

3. `async acceptOffer(offerCode: string): Promise<SDPCodecResult<string>>`
   - Set state to 'creating_answer', set role to 'responder'
   - Decode offer with sdpCodec.decodeSDP
   - Create RTCPeerConnection
   - Set up ondatachannel handler to capture channels created by initiator
   - Set remote description from decoded offer
   - Create answer: `await pc.createAnswer()`
   - Set local description: `await pc.setLocalDescription(answer)`
   - Wait for ICE gathering complete
   - Encode final SDP
   - Set state to 'connecting'
   - Return encoded answer

4. `async acceptAnswer(answerCode: string): Promise<SDPCodecResult<void>>`
   - Decode answer with sdpCodec.decodeSDP
   - Set remote description
   - Set state to 'connecting'
   - Return success (connection establishment handled by ICE)

5. `disconnect(): void`
   - Close DataChannels if open
   - Close RTCPeerConnection if exists
   - Set state to 'disconnected'
   - Reset role to null

6. `getState(): ConnectionState`
   - Return current state

7. `sendControl(message: Omit<ControlMessage, 'timestamp' | 'id'>): boolean`
   - Add timestamp and nanoid id
   - Send JSON string via controlChannel
   - Return false if channel not ready

8. `sendBinary(data: ArrayBuffer): boolean`
   - Send via binaryChannel
   - Return false if channel not ready

**Private helper:**

`private waitForIceGathering(): Promise<void>`
- Return immediately if `pc.iceGatheringState === 'complete'`
- Otherwise, create Promise that resolves on 'icegatheringstatechange' when complete
- Add timeout (config.iceGatheringTimeout) that rejects with error
- Clean up listener on resolve/reject

**Event handlers setup:**
- `pc.oniceconnectionstatechange`: Update state to 'connected' when 'connected', 'error' when 'failed'
- `pc.ondatachannel` (responder only): Store received channels, set up their handlers
- DataChannel `onopen`: When BOTH channels open, set state to 'connected'
- DataChannel `onmessage`: Route to appropriate callback (control parses JSON, binary passes ArrayBuffer)
- DataChannel `onerror`/`onclose`: Set state to 'error' or 'disconnected'

**Critical details:**
- Use Promise-based WebRTC API only (Safari compatibility)
- Check `readyState === 'open'` before sending on channels
- Log state transitions to console for debugging
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify class can be instantiated: `new WebRTCConnectionService()`
  </verify>
  <done>
WebRTCConnectionService exports from connection.ts, handles full offer/answer lifecycle with dual DataChannels, state transitions tracked via callbacks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add connection event handling and channel state tracking</name>
  <files>client/src/services/webrtc/connection.ts</files>
  <action>
Enhance the WebRTCConnectionService with robust event handling:

1. **Track channel ready state:**
   - Add private `controlReady: boolean` and `binaryReady: boolean`
   - Set to true in respective `onopen` handlers
   - Only transition to 'connected' when BOTH are true
   - Reset both to false on disconnect

2. **Add connection state change handling:**
   ```typescript
   private setupPeerConnectionEvents(): void {
     if (!this.pc) return;

     this.pc.oniceconnectionstatechange = () => {
       console.log('[WebRTC] ICE state:', this.pc?.iceConnectionState);

       switch (this.pc?.iceConnectionState) {
         case 'connected':
         case 'completed':
           // Don't set connected here - wait for DataChannels
           break;
         case 'failed':
           this.setState('error');
           break;
         case 'disconnected':
           // May recover, don't immediately error
           console.log('[WebRTC] ICE disconnected, may recover');
           break;
         case 'closed':
           this.setState('disconnected');
           break;
       }
     };

     this.pc.onicecandidateerror = (e) => {
       console.warn('[WebRTC] ICE candidate error:', e);
     };
   }
   ```

3. **Add private setState helper:**
   ```typescript
   private setState(newState: ConnectionState): void {
     if (this.state === newState) return;
     console.log(`[WebRTC] State: ${this.state} -> ${newState}`);
     this.state = newState;
     this.onStateChange?.(newState);
   }
   ```

4. **Add DataChannel setup helper:**
   ```typescript
   private setupDataChannel(
     channel: RTCDataChannel,
     type: 'control' | 'binary'
   ): void {
     channel.onopen = () => {
       console.log(`[WebRTC] ${type} channel opened`);
       if (type === 'control') this.controlReady = true;
       else this.binaryReady = true;
       this.checkChannelsReady();
     };

     channel.onclose = () => {
       console.log(`[WebRTC] ${type} channel closed`);
       if (type === 'control') this.controlReady = false;
       else this.binaryReady = false;
     };

     channel.onerror = (e) => {
       console.error(`[WebRTC] ${type} channel error:`, e);
       this.setState('error');
     };

     channel.onmessage = (e) => {
       if (type === 'control') {
         try {
           const msg = JSON.parse(e.data) as ControlMessage;
           this.onControlMessage?.(msg);
         } catch (err) {
           console.error('[WebRTC] Failed to parse control message:', err);
         }
       } else {
         this.onBinaryMessage?.(e.data as ArrayBuffer);
       }
     };
   }

   private checkChannelsReady(): void {
     if (this.controlReady && this.binaryReady) {
       this.setState('connected');
     }
   }
   ```

5. **Update createOffer to use helpers:**
   - Call `setupPeerConnectionEvents()` after creating pc
   - Call `setupDataChannel(channel, type)` for each channel

6. **Update acceptOffer ondatachannel:**
   ```typescript
   this.pc.ondatachannel = (event) => {
     const channel = event.channel;
     console.log('[WebRTC] Received channel:', channel.label);

     if (channel.label === 'control') {
       this.controlChannel = channel;
       this.setupDataChannel(channel, 'control');
     } else if (channel.label === 'binary') {
       this.binaryChannel = channel;
       this.setupDataChannel(channel, 'binary');
     }
   };
   ```
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Review console.log statements provide clear debugging info.
  </verify>
  <done>
Connection service has robust event handling, state transitions logged, both DataChannels must be ready before 'connected' state.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- WebRTCConnectionService can be imported: `import { WebRTCConnectionService } from '@/services/webrtc/connection'`
- Class has all required public methods: createOffer, acceptOffer, acceptAnswer, disconnect, getState, sendControl, sendBinary
- State machine transitions are logged to console for debugging
</verification>

<success_criteria>
- CONN-01: createOffer() generates encoded offer code
- CONN-02: acceptOffer() decodes offer and generates answer
- CONN-03: acceptAnswer() completes handshake
- CONN-04: Both DataChannels open triggers 'connected' state
- Service handles errors gracefully without crashing
</success_criteria>

<output>
After completion, create `.planning/phases/01-webrtc-connection/01-02-SUMMARY.md`
</output>
