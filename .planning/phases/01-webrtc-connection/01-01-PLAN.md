---
phase: 01-webrtc-connection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/types/sync.ts
  - client/src/services/webrtc/sdpCodec.ts
autonomous: true

must_haves:
  truths:
    - "SDP offer can be encoded to URL-safe string under 2000 chars"
    - "Encoded SDP can be decoded back to valid RTCSessionDescription"
    - "Invalid/corrupted codes are detected and rejected with clear error"
  artifacts:
    - path: "client/src/types/sync.ts"
      provides: "Connection state machine types, message protocol types"
      exports: ["ConnectionState", "ConnectionRole", "ControlMessage", "SDPCodecResult"]
    - path: "client/src/services/webrtc/sdpCodec.ts"
      provides: "SDP encoding/decoding with lz-string compression"
      exports: ["encodeSDP", "decodeSDP", "validateSDP"]
  key_links:
    - from: "client/src/services/webrtc/sdpCodec.ts"
      to: "lz-string"
      via: "compressToEncodedURIComponent/decompressFromEncodedURIComponent"
      pattern: "compressToEncodedURIComponent|decompressFromEncodedURIComponent"
---

<objective>
Define TypeScript types for P2P sync and implement the SDP codec for encoding/decoding WebRTC session descriptions as shareable codes.

Purpose: Establish the type foundation and codec that enables manual SDP exchange - the core mechanism for serverless P2P connection.

Output: Type definitions in sync.ts, working SDP codec in sdpCodec.ts with compression.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@client/src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync types</name>
  <files>client/src/types/sync.ts</files>
  <action>
Create TypeScript types for the P2P sync system:

1. **ConnectionState** - State machine states:
   - `disconnected` - No active connection
   - `creating_offer` - Generating SDP offer (initiator)
   - `awaiting_answer` - Waiting for peer's answer (initiator)
   - `creating_answer` - Generating SDP answer (responder)
   - `connecting` - ICE negotiation in progress
   - `connected` - DataChannels open and ready
   - `error` - Connection failed

2. **ConnectionRole** - `'initiator' | 'responder'`

3. **SDPCodecResult** - Result type for codec operations:
   ```typescript
   type SDPCodecResult<T> =
     | { success: true; data: T }
     | { success: false; error: string };
   ```

4. **ControlMessage** - Base type for control channel messages:
   ```typescript
   interface ControlMessage {
     type: string;
     timestamp: number;
     id: string;
   }
   ```

5. **ConnectionConfig** - Configuration for WebRTC:
   ```typescript
   interface ConnectionConfig {
     iceServers: RTCIceServer[];
     iceGatheringTimeout: number;
   }
   ```

6. **DEFAULT_ICE_SERVERS** - Constant with Google and Cloudflare STUN:
   ```typescript
   const DEFAULT_ICE_SERVERS: RTCIceServer[] = [
     { urls: 'stun:stun.l.google.com:19302' },
     { urls: 'stun:stun1.l.google.com:19302' },
     { urls: 'stun:stun.cloudflare.com:3478' },
   ];
   ```

Export all types and constants.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root - no type errors in sync.ts
  </verify>
  <done>
Types compile without errors, all exports accessible from other files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Install lz-string and implement SDP codec</name>
  <files>client/src/services/webrtc/sdpCodec.ts</files>
  <action>
First, install lz-string:
```bash
pnpm add lz-string
pnpm add -D @types/lz-string
```

Then create the SDP codec service:

1. **encodeSDP(sdp: RTCSessionDescriptionInit): SDPCodecResult<string>**
   - Validate sdp has type and sdp fields
   - Create compact JSON: `{ t: sdp.type, s: sdp.sdp }`
   - Compress with `compressToEncodedURIComponent`
   - Return success with encoded string
   - On any error, return failure with descriptive message

2. **decodeSDP(code: string): SDPCodecResult<RTCSessionDescriptionInit>**
   - Decompress with `decompressFromEncodedURIComponent`
   - If null, return failure "Invalid or corrupted code"
   - Parse JSON, validate has `t` and `s` fields
   - Return `{ type: t, sdp: s }` wrapped in success
   - On any error, return failure with descriptive message

3. **validateSDP(sdp: RTCSessionDescriptionInit): boolean**
   - Check type is 'offer' or 'answer'
   - Check sdp string exists and contains 'v=0' (SDP version line)
   - Return true if valid

Add JSDoc comments explaining:
- Why lz-string (URL-safe, good compression for SDP text)
- Expected code length (~1000-1500 chars from ~3KB SDP)
- Non-trickle ICE requirement (must wait for ICE gathering complete)
  </action>
  <verify>
Create a quick test in Node REPL or a temp file:
```typescript
const testSdp = { type: 'offer', sdp: 'v=0\r\no=- 123 2 IN IP4 127.0.0.1\r\n...' };
const encoded = encodeSDP(testSdp);
console.log('Encoded length:', encoded.data?.length);
const decoded = decodeSDP(encoded.data);
console.log('Roundtrip OK:', decoded.data?.type === 'offer');
```
Run `npx tsc --noEmit` - no type errors.
  </verify>
  <done>
lz-string installed, sdpCodec.ts exports encodeSDP, decodeSDP, validateSDP. Encoding reduces SDP size, roundtrip preserves data.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- `pnpm list lz-string` shows package installed
- Types in sync.ts are importable: `import { ConnectionState } from '@/types/sync'`
- Codec functions work: encode -> decode roundtrip preserves SDP content
</verification>

<success_criteria>
- CONN-01 foundation: Types and codec ready for offer generation
- CONN-02 foundation: Codec ready for offer decoding
- Code compresses ~3KB SDP to ~1000-1500 char URL-safe string
- Invalid codes rejected with clear error messages
</success_criteria>

<output>
After completion, create `.planning/phases/01-webrtc-connection/01-01-SUMMARY.md`
</output>
