---
phase: 04-editor-role-system
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - client/src/pages/Home.tsx
  - client/src/components/Card.tsx
  - client/src/components/CardList.tsx
  - client/src/hooks/useKeyboardShortcuts.ts
autonomous: true

must_haves:
  truths:
    - "UI prevents editing when in Viewer role (ROLE-04)"
    - "Recording button is disabled for viewers"
    - "Card edit/delete/duplicate buttons are disabled for viewers"
    - "Drag-and-drop reordering is disabled for viewers"
    - "Inline title editing is disabled for viewers"
    - "Keyboard shortcuts check canEdit before executing"
  artifacts:
    - path: "client/src/pages/Home.tsx"
      provides: "Passes canEdit to components, wires RoleRequestDialog"
      contains: "canEdit"
    - path: "client/src/components/Card.tsx"
      provides: "Editing controls disabled when viewer"
      contains: "canEdit"
    - path: "client/src/components/CardList.tsx"
      provides: "Drag-drop disabled when viewer"
      contains: "canEdit"
    - path: "client/src/hooks/useKeyboardShortcuts.ts"
      provides: "Shortcuts check canEdit"
      contains: "canEdit"
  key_links:
    - from: "client/src/pages/Home.tsx"
      to: "client/src/contexts/SyncContext.tsx"
      via: "useSync hook for canEdit"
      pattern: "canEdit.*useSync"
---

<objective>
Enforce UI editing restrictions when user is a viewer.

Purpose: Prevent viewers from making edits that won't sync, avoid confusion.

Output: All editing controls disabled for viewers, keyboard shortcuts respect canEdit.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-editor-role-system/04-RESEARCH.md
@.planning/phases/04-editor-role-system/04-02-PLAN.md
@.planning/phases/04-editor-role-system/04-03-PLAN.md

# Files to modify
@client/src/pages/Home.tsx
@client/src/components/Card.tsx
@client/src/components/CardList.tsx
@client/src/hooks/useKeyboardShortcuts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Home.tsx with canEdit and role dialogs</name>
  <files>client/src/pages/Home.tsx</files>
  <action>
Update Home.tsx to get canEdit from SyncContext, pass to components, and wire up RoleRequestDialog.

1. Update useSync destructuring to include new values:
```typescript
const {
  setConnection,
  setUserRole,
  syncState,
  connectionState,
  startSync,
  commitSync,
  canEdit,
  roleTransferState,
  requestRole,
  grantRole,
  denyRole,
} = useSync();
```

2. Import RoleRequestDialog:
```typescript
import { RoleRequestDialog } from '@/components/RoleRequestDialog';
```

3. Update Header props to include role props:
```tsx
<Header
  // ... existing props ...
  role={syncState.role}
  roleTransferState={roleTransferState}
  onRequestRole={requestRole}
/>
```

4. Add RoleRequestDialog component (after ConfirmDialog):
```tsx
{/* Role request approval dialog for editor */}
<RoleRequestDialog
  isOpen={roleTransferState.status === 'pending_approval'}
  onGrant={grantRole}
  onDeny={() => denyRole()}
/>
```

5. Pass canEdit to CardList:
```tsx
<CardList
  // ... existing props ...
  canEdit={canEdit}
/>
```

6. Update RecordingPanel trigger area - disable the floating record button for viewers.
Find where the main recording button/FAB is rendered and add disabled state:
```tsx
disabled={!canEdit}
title={canEdit ? "Record new card" : "View only - request editor role to record"}
```

7. Update handleInsertAt to check canEdit:
```typescript
const handleInsertAt = (position: number) => {
  if (!canEdit) return; // Viewer cannot insert
  // ... existing code ...
};
```

8. Update handler functions that trigger editing to early-return if !canEdit:
- handleCardReRecord
- handleCardAppend
- handleCardDuplicate
- handleCardDelete
- handleCardTrimSplit
- handleTrim
- handleSplit
- handleCardAddSilenceStart/End
- handleCardRemoveSilenceStart/End
- handleMerge
- handleBatchDelete

Add at start of each: `if (!canEdit) return;`

Note: The actual UI disabling happens in Card.tsx and CardList.tsx. These early returns are safety checks.
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>Home.tsx wired with canEdit, RoleRequestDialog, role props to Header</done>
</task>

<task type="auto">
  <name>Task 2: Disable editing controls in Card.tsx</name>
  <files>client/src/components/Card.tsx</files>
  <action>
Update Card.tsx to accept canEdit prop and disable editing controls for viewers.

1. Add canEdit to CardProps interface:
```typescript
interface CardProps {
  // ... existing props ...
  canEdit?: boolean;
}
```

2. Update function signature to include canEdit with default true:
```typescript
export function Card({
  // ... existing props ...
  canEdit = true,
}: CardProps) {
```

3. Disable inline title editing for viewers - update handleTitleDoubleClick:
```typescript
const handleTitleDoubleClick = () => {
  if (!canEdit) return; // Viewer cannot edit title
  setIsEditingTitle(true);
  setEditedTitle(card.label);
};
```

4. Disable quick action buttons (duplicate, delete) in the hidden sm:flex section:
```tsx
<Button
  variant="ghost"
  size="icon"
  className="shrink-0 hover:bg-muted h-8 w-8"
  onClick={(e) => {
    e.stopPropagation();
    onDuplicate();
  }}
  disabled={!canEdit}
  title={canEdit ? "Duplicate" : "View only"}
>
  <Copy className="w-4 h-4" />
</Button>
<Button
  variant="ghost"
  size="icon"
  className="shrink-0 hover:bg-destructive/10 hover:text-destructive h-8 w-8"
  onClick={(e) => {
    e.stopPropagation();
    onDelete();
  }}
  disabled={!canEdit}
  title={canEdit ? "Delete" : "View only"}
>
  <Trash2 className="w-4 h-4" />
</Button>
```

5. Disable dropdown menu items for viewers - add disabled={!canEdit} to editing-related items:
- Edit Details
- Re-record
- Append Audio
- Trim/Split
- Add Silence Start/End
- Remove Silence Start/End
- Duplicate
- Delete

Example for one item:
```tsx
<DropdownMenuItem onClick={onEdit} disabled={!canEdit}>
  <Pencil className="w-4 h-4 mr-2" />
  Edit Details
</DropdownMenuItem>
```

Keep Generate Transcript and Toggle Transcript enabled (read-only operations).

6. Update title element to show different cursor when viewer:
```tsx
<h3
  className={cn(
    "font-display font-semibold text-lg truncate transition-colors",
    canEdit && "cursor-text hover:text-primary"
  )}
  onDoubleClick={handleTitleDoubleClick}
  title={canEdit ? "Double-click to edit" : card.label}
>
  {card.label}
</h3>
```
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>Card.tsx editing controls disabled when canEdit is false</done>
</task>

<task type="auto">
  <name>Task 3: Disable drag-drop in CardList.tsx</name>
  <files>client/src/components/CardList.tsx</files>
  <action>
Update CardList.tsx to accept canEdit prop and disable drag-drop for viewers.

1. Add canEdit to CardListProps interface:
```typescript
interface CardListProps {
  // ... existing props ...
  canEdit?: boolean;
}
```

2. Update function signature to include canEdit:
```typescript
export function CardList({
  // ... existing props ...
  canEdit = true,
}: CardListProps) {
```

3. Disable drag sensors when viewer. Find where useSensors or sensors are configured.
Option A - If using useSensors, add disabled check to activation constraints:
```typescript
const sensors = useSensors(
  useSensor(PointerSensor, {
    activationConstraint: canEdit
      ? { distance: 8 }
      : { distance: Infinity }, // Never activates for viewer
  }),
  useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates,
  })
);
```

Option B - Conditionally pass dragListeners to Card:
```tsx
<Card
  // ... existing props ...
  dragListeners={canEdit ? dragListeners : undefined}
  canEdit={canEdit}
/>
```

4. Conditionally render or style the drag handle in CardList (if drag handle is here).
If drag handle is rendered in CardList, conditionally render it:
```tsx
{canEdit && (
  <div {...attributes} {...listeners} className="cursor-grab">
    <GripVertical className="w-5 h-5 text-muted-foreground" />
  </div>
)}
```

Or hide with CSS:
```tsx
<div
  {...attributes}
  {...listeners}
  className={cn("cursor-grab", !canEdit && "opacity-0 pointer-events-none")}
>
```

5. Pass canEdit to each Card component:
```tsx
<Card
  // ... existing props ...
  canEdit={canEdit}
/>
```

Note: The drag handle is rendered in Card.tsx (see lines 469-476). CardList should pass dragListeners conditionally or pass canEdit to Card which will handle it.
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>CardList.tsx drag-drop disabled when canEdit is false, canEdit passed to Card</done>
</task>

<task type="auto">
  <name>Task 4: Update keyboard shortcuts to check canEdit</name>
  <files>client/src/hooks/useKeyboardShortcuts.ts</files>
  <action>
Update useKeyboardShortcuts to accept canEdit prop and check before executing editing shortcuts.

1. Add canEdit to the options interface:
```typescript
interface UseKeyboardShortcutsOptions {
  // ... existing options ...
  canEdit?: boolean;
}
```

2. Update the hook signature:
```typescript
export function useKeyboardShortcuts({
  // ... existing options ...
  canEdit = true,
}: UseKeyboardShortcutsOptions) {
```

3. Wrap editing shortcuts in canEdit check. Find the keyboard event handler and update editing-related shortcuts:

For record shortcut (R):
```typescript
if (e.key === 'r' && !e.metaKey && !e.ctrlKey) {
  if (!canEdit) return; // Viewer cannot record
  e.preventDefault();
  onRecord?.();
}
```

For undo shortcut (Ctrl+Z):
```typescript
if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
  if (!canEdit) return; // Viewer cannot undo
  e.preventDefault();
  onUndo?.();
}
```

For redo shortcut (Ctrl+Shift+Z or Ctrl+Y):
```typescript
if ((e.metaKey || e.ctrlKey) && (e.key === 'Z' && e.shiftKey || e.key === 'y')) {
  if (!canEdit) return; // Viewer cannot redo
  e.preventDefault();
  onRedo?.();
}
```

For delete shortcut (if any - Backspace/Delete):
```typescript
if (e.key === 'Backspace' || e.key === 'Delete') {
  if (!canEdit) return; // Viewer cannot delete
  // ... existing code ...
}
```

4. Keep non-editing shortcuts enabled:
- Play/Pause (Space)
- Seek forward/backward (Arrow keys)
- Jump to card (1-9 number keys)
These are read-only operations and should work for viewers.

5. Update Home.tsx to pass canEdit to useKeyboardShortcuts:
In Home.tsx, update the useKeyboardShortcuts call:
```typescript
useKeyboardShortcuts({
  onPlayPause: handlePlayPause,
  onRecord: () => handleInsertAt(state.cards.length),
  onSeekForward: () => seekToTime(Math.min(globalTime + 5, totalDuration)),
  onSeekBackward: () => seekToTime(Math.max(globalTime - 5, 0)),
  onEdit: () => {
    if (state.cards.length > 0) {
      setEditingCard(state.cards[0]);
    }
  },
  onUndo: undo,
  onRedo: redo,
  onJumpToCard: (index: number) => {
    if (index >= 0 && index < filteredCards.length) {
      const card = filteredCards[index];
      jumpToCard(card.id);
      if (!isPlaying) {
        play();
      }
    }
  },
  canEdit, // Add this
});
```
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>Keyboard shortcuts check canEdit before executing editing actions</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. When viewer: record button disabled, card action buttons disabled
3. When viewer: drag-drop doesn't work, inline title edit doesn't work
4. When viewer: keyboard shortcuts R, Ctrl+Z, Ctrl+Shift+Z don't execute editing
5. When viewer: playback controls still work (play, pause, seek)
6. RoleRequestDialog appears for editor when pending_approval
</verification>

<success_criteria>
- ROLE-04: All editing controls disabled/hidden when viewer
- Viewers can still: play audio, seek, navigate, view transcripts
- Viewers cannot: record, edit, delete, duplicate, reorder, undo/redo
- No editing actions execute via keyboard shortcuts for viewers
</success_criteria>

<output>
After completion, create `.planning/phases/04-editor-role-system/04-04-SUMMARY.md`
</output>
