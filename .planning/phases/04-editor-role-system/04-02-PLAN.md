---
phase: 04-editor-role-system
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - client/src/contexts/SyncContext.tsx
autonomous: true

must_haves:
  truths:
    - "Role transfer state machine tracks request lifecycle (idle, pending_request, pending_approval, transferring, denied)"
    - "canEdit computed value derives editing permission from role and transfer state"
    - "Role messages are handled and state transitions occur correctly"
    - "Editing is paused during role transfer (ROLE-05)"
  artifacts:
    - path: "client/src/contexts/SyncContext.tsx"
      provides: "Role transfer state, handlers, canEdit computed value"
      contains: "RoleTransferState"
  key_links:
    - from: "client/src/contexts/SyncContext.tsx"
      to: "client/src/services/webrtc/syncProtocol.ts"
      via: "Role message creators and type guard"
      pattern: "createRoleGrant|isRoleMessage"
---

<objective>
Add role transfer state management and message handlers to SyncContext.

Purpose: Enable role transfer negotiation state machine and provide canEdit computed value for UI enforcement.

Output: SyncContext with roleTransferState, role message handlers, canEdit, requestRole, grantRole, denyRole functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-editor-role-system/04-RESEARCH.md
@.planning/phases/04-editor-role-system/04-01-PLAN.md

# Files to modify
@client/src/contexts/SyncContext.tsx
@client/src/services/webrtc/syncProtocol.ts
@client/src/types/sync.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add role transfer state and types</name>
  <files>client/src/contexts/SyncContext.tsx</files>
  <action>
Add role transfer state machine to SyncContext.

1. Add imports for new types and creators at top of file:
```typescript
import {
  createRoleRequest,
  createRoleGrant,
  createRoleDeny,
  createRoleTransferComplete,
  isRoleMessage,
} from '@/services/webrtc/syncProtocol';
import type { RoleMessage } from '@/types/sync';
```

2. Add RoleTransferState type after the existing types section:
```typescript
/**
 * Role transfer request lifecycle state.
 * Tracks the async role request/grant/deny flow.
 */
type RoleTransferState =
  | { status: 'idle' }
  | { status: 'pending_request' }       // Viewer: waiting for editor response
  | { status: 'pending_approval' }      // Editor: has pending request from viewer
  | { status: 'transferring' }          // Brief pause during role handoff
  | { status: 'denied'; reason?: string };  // Viewer: request was denied
```

3. Add roleTransferState to SyncState interface:
```typescript
interface SyncState {
  // ... existing fields ...
  roleTransferState: RoleTransferState;
}
```

4. Update initialSyncState to include:
```typescript
roleTransferState: { status: 'idle' },
```

5. Add to SyncContextValue interface:
```typescript
interface SyncContextValue {
  // ... existing fields ...

  // Role transfer (ROLE-02, ROLE-03, ROLE-05)
  canEdit: boolean;
  roleTransferState: RoleTransferState;
  requestRole: (reason?: string) => void;
  grantRole: () => void;
  denyRole: (reason?: string) => void;
}
```
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>RoleTransferState type defined, added to SyncState and SyncContextValue</done>
</task>

<task type="auto">
  <name>Task 2: Add canEdit computed value and role handlers</name>
  <files>client/src/contexts/SyncContext.tsx</files>
  <action>
Add canEdit computation and role transfer handlers in SyncProvider.

1. Add canEdit useMemo after the existing state declarations:
```typescript
/**
 * Computed editing permission.
 * - Not connected = can edit (local only mode)
 * - During role transfer = nobody edits (ROLE-05)
 * - Only editor can edit when connected
 */
const canEdit = useMemo(() => {
  // Not connected = can edit (local only mode)
  if (connectionState !== 'connected') return true;
  // During role transfer = nobody edits
  if (syncState.roleTransferState.status === 'transferring') return false;
  // Only editor can edit
  return syncState.role === 'editor';
}, [connectionState, syncState.roleTransferState.status, syncState.role]);
```

2. Add role request handler (viewer calls this):
```typescript
/**
 * Request editor role from current editor.
 * Viewer calls this to initiate role transfer.
 */
const requestRole = useCallback((reason?: string) => {
  if (!connectionRef.current?.isReady() || syncState.role !== 'viewer') {
    return;
  }

  console.log('[Sync] Requesting editor role');

  // Update state to pending_request
  setSyncState((prev) => ({
    ...prev,
    roleTransferState: { status: 'pending_request' },
  }));

  // Send request to editor
  connectionRef.current.sendControl(createRoleRequest(reason));
}, [syncState.role]);
```

3. Add grant role handler (editor calls this):
```typescript
/**
 * Grant editor role to viewer.
 * Editor calls this to approve role request.
 */
const grantRole = useCallback(() => {
  if (!connectionRef.current?.isReady() || syncState.role !== 'editor') {
    return;
  }

  console.log('[Sync] Granting editor role');

  // Enter transferring state (ROLE-05: pause editing)
  setSyncState((prev) => ({
    ...prev,
    roleTransferState: { status: 'transferring' },
  }));

  // Send grant to viewer
  connectionRef.current.sendControl(createRoleGrant());

  // Swap roles locally: we become viewer
  userRoleRef.current = 'viewer';
  setSyncState((prev) => ({
    ...prev,
    role: 'viewer',
    roleTransferState: { status: 'idle' },
  }));
}, [syncState.role]);
```

4. Add deny role handler (editor calls this):
```typescript
/**
 * Deny role request from viewer.
 * Editor calls this to reject role request.
 */
const denyRole = useCallback((reason?: string) => {
  if (!connectionRef.current?.isReady() || syncState.role !== 'editor') {
    return;
  }

  console.log('[Sync] Denying role request:', reason);

  // Clear pending approval state
  setSyncState((prev) => ({
    ...prev,
    roleTransferState: { status: 'idle' },
  }));

  // Send denial to viewer
  connectionRef.current.sendControl(createRoleDeny(reason));
}, [syncState.role]);
```

5. Add role message handlers:
```typescript
/**
 * Handle incoming role messages.
 */
const handleRoleMessage = useCallback((msg: RoleMessage) => {
  console.log('[Sync] Received role message:', msg.type);

  switch (msg.type) {
    case 'role_request':
      // Editor receives request from viewer
      if (syncState.role === 'editor') {
        setSyncState((prev) => ({
          ...prev,
          roleTransferState: { status: 'pending_approval' },
        }));
      }
      break;

    case 'role_grant':
      // Viewer receives grant from editor
      if (syncState.role === 'viewer') {
        console.log('[Sync] Role granted - becoming editor');

        // Enter transferring state briefly (ROLE-05)
        setSyncState((prev) => ({
          ...prev,
          roleTransferState: { status: 'transferring' },
        }));

        // Swap roles: we become editor
        userRoleRef.current = 'editor';
        setSyncState((prev) => ({
          ...prev,
          role: 'editor',
          roleTransferState: { status: 'idle' },
        }));

        // Send transfer complete to old editor
        connectionRef.current?.sendControl(createRoleTransferComplete());
      }
      break;

    case 'role_deny':
      // Viewer receives denial from editor
      if (syncState.role === 'viewer') {
        setSyncState((prev) => ({
          ...prev,
          roleTransferState: { status: 'denied', reason: msg.reason },
        }));

        // Clear denied state after 3 seconds
        setTimeout(() => {
          setSyncState((prev) => {
            if (prev.roleTransferState.status === 'denied') {
              return { ...prev, roleTransferState: { status: 'idle' } };
            }
            return prev;
          });
        }, 3000);
      }
      break;

    case 'role_transfer_complete':
      // Old editor receives confirmation from new editor
      setSyncState((prev) => ({
        ...prev,
        roleTransferState: { status: 'idle' },
      }));
      break;
  }
}, [syncState.role]);
```

6. Update onControlMessage callback to route role messages:
In the setConnection callback where onControlMessage is defined, add routing for role messages BEFORE the sync control messages:

```typescript
onControlMessage: (msg) => {
  // Route role messages first
  if (isRoleMessage(msg)) {
    handleRoleMessage(msg as RoleMessage);
  } else if (isOperationMessage(msg)) {
    handleOperationMessage(msg as SyncOperation);
  } else if (isSyncControlMessage(msg)) {
    handleSyncMessage(msg as SyncControlMessage);
  } else {
    console.warn('[Sync] Unknown message type:', msg.type);
  }
},
```

7. Add cleanup on disconnect - in the setConnection callback where connection is null:
```typescript
if (!conn) {
  // ... existing cleanup ...
  // Reset role transfer state on disconnect
  setSyncState((prev) => ({
    ...prev,
    roleTransferState: { status: 'idle' },
  }));
}
```

8. Update the context value to include new fields:
```typescript
const value: SyncContextValue = {
  // ... existing fields ...
  canEdit,
  roleTransferState: syncState.roleTransferState,
  requestRole,
  grantRole,
  denyRole,
};
```
  </action>
  <verify>npx tsc --noEmit (no type errors)</verify>
  <done>canEdit computed, role handlers implemented, role messages routed correctly</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. SyncContext exports canEdit, roleTransferState, requestRole, grantRole, denyRole
3. Role messages are routed via isRoleMessage type guard
4. canEdit returns false during 'transferring' state (ROLE-05)
5. Role transfer state resets on disconnect
</verification>

<success_criteria>
- ROLE-05: canEdit is false during 'transferring' state (editing paused during transfer)
- Role request/grant/deny flow updates state correctly
- State machine transitions: idle -> pending_request/pending_approval -> transferring -> idle
- Cleanup on disconnect prevents stuck states
</success_criteria>

<output>
After completion, create `.planning/phases/04-editor-role-system/04-02-SUMMARY.md`
</output>
