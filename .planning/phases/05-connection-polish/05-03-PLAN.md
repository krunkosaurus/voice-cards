---
phase: 05-connection-polish
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - client/src/contexts/SyncContext.tsx
autonomous: true

must_haves:
  truths:
    - "Context starts heartbeat when connection becomes connected"
    - "Context handles heartbeat timeout by transitioning to reconnecting state"
    - "Context handles peer disconnect message by NOT auto-reconnecting"
    - "Context attempts reconnection with exponential backoff (3 attempts)"
    - "Context exposes reconnection state (attempts, max attempts)"
  artifacts:
    - path: "client/src/contexts/SyncContext.tsx"
      provides: "ReconnectionState, heartbeat wiring, handleHeartbeatTimeout, handlePeerDisconnect"
      contains: "ReconnectionState"
  key_links:
    - from: "client/src/contexts/SyncContext.tsx"
      to: "client/src/services/webrtc/connection.ts"
      via: "onHeartbeatTimeout, onPeerDisconnect callbacks"
      pattern: "onHeartbeatTimeout"
---

<objective>
Add reconnection state machine to SyncContext for handling connection drops with exponential backoff.

Purpose: Implement CONN-07 (auto-recover from drops) by detecting heartbeat timeout, transitioning to "reconnecting" state, and attempting reconnection with exponential backoff. Distinguish between network failures (auto-reconnect) and peer disconnect (no reconnect).

Output: SyncContext with reconnection state machine, heartbeat integration, and exposed reconnection status for UI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-connection-polish/05-CONTEXT.md
@.planning/phases/05-connection-polish/05-RESEARCH.md
@.planning/phases/05-connection-polish/05-01-SUMMARY.md
@.planning/phases/05-connection-polish/05-02-SUMMARY.md
@client/src/contexts/SyncContext.tsx
@client/src/services/webrtc/connection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reconnection state and types</name>
  <files>client/src/contexts/SyncContext.tsx</files>
  <action>
Add reconnection state management to SyncContext:

1. Add ReconnectionState type after RoleTransferState type:
```typescript
/**
 * Reconnection attempt state.
 * Tracks auto-reconnect attempts after network failure.
 */
type ReconnectionState =
  | { status: 'idle' }
  | { status: 'reconnecting'; attempt: number; maxAttempts: number }
  | { status: 'failed'; reason: string }  // Gave up after max attempts
  | { status: 'peer_disconnected' };  // Peer intentionally disconnected (no auto-reconnect)
```

2. Add reconnectionState to SyncState interface:
```typescript
interface SyncState {
  isSyncing: boolean;
  role: UserRole | null;
  progress: SyncProgress;
  pendingRequest: PendingSyncRequest | null;
  receivedProject: Project | null;
  receivedCards: Card[];
  receivedAudio: Map<string, Blob>;
  roleTransferState: RoleTransferState;
  reconnectionState: ReconnectionState;  // ADD THIS
  connectedAt: number | null;  // ADD THIS - timestamp when connected
}
```

3. Update initialSyncState:
```typescript
const initialSyncState: SyncState = {
  isSyncing: false,
  role: null,
  progress: initialProgress,
  pendingRequest: null,
  receivedProject: null,
  receivedCards: [],
  receivedAudio: new Map(),
  roleTransferState: { status: 'idle' },
  reconnectionState: { status: 'idle' },
  connectedAt: null,
};
```

4. Add reconnection config constants after initialSyncState:
```typescript
// Reconnection config
const RECONNECT_BASE_DELAY = 2000;  // 2s initial delay
const RECONNECT_MAX_DELAY = 8000;   // 8s max delay
const RECONNECT_MAX_ATTEMPTS = 3;   // 3 attempts then give up
```

5. Add to SyncContextValue interface:
```typescript
interface SyncContextValue {
  // ... existing fields ...

  // Reconnection state (CONN-07)
  reconnectionState: ReconnectionState;
  connectedAt: number | null;
  resetReconnectionState: () => void;  // For "Try again" button
}
```
  </action>
  <verify>
Run: `cd /Users/krunkosaurus/Documents/git/voice-cards && npm run typecheck`
TypeScript compiles without errors.
  </verify>
  <done>
ReconnectionState type defined. SyncState includes reconnectionState and connectedAt. SyncContextValue exposes reconnectionState and connectedAt.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire heartbeat and handle connection events</name>
  <files>client/src/contexts/SyncContext.tsx</files>
  <action>
Wire heartbeat callbacks and implement reconnection logic:

1. Add ref for reconnection timer (after other refs):
```typescript
const reconnectTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
```

2. Modify setConnection callback to wire heartbeat callbacks:
Update the conn.setCallbacks call to include:
```typescript
conn.setCallbacks({
  onStateChange: (state) => {
    setConnectionState(state);

    // Start heartbeat when connected
    if (state === 'connected') {
      conn.startHeartbeat();
      // Record connection time
      setSyncState((prev) => ({
        ...prev,
        connectedAt: Date.now(),
        reconnectionState: { status: 'idle' },
      }));
    }

    // Stop heartbeat on disconnect/error
    if (state === 'disconnected' || state === 'error') {
      conn.stopHeartbeat();
    }
  },
  onControlMessage: (msg) => {
    // ... existing message routing ...
  },
  onBinaryMessage: (data) => {
    handleBinaryMessage(data);
  },
  onHeartbeatTimeout: () => {
    handleHeartbeatTimeout();
  },
  onPeerDisconnect: (reason) => {
    handlePeerDisconnect(reason);
  },
});
```

3. Add handleHeartbeatTimeout function (before setConnection):
```typescript
/**
 * Handle heartbeat timeout - connection is stale.
 * Transition to reconnecting state and attempt recovery.
 * CONN-07: Auto-recover from connection drops.
 */
const handleHeartbeatTimeout = useCallback(() => {
  console.log('[Sync] Heartbeat timeout - attempting reconnect');

  // Transition to reconnecting state
  setConnectionState('reconnecting');
  setSyncState((prev) => ({
    ...prev,
    reconnectionState: {
      status: 'reconnecting',
      attempt: 1,
      maxAttempts: RECONNECT_MAX_ATTEMPTS,
    },
  }));

  // Note: Full reconnection requires re-exchanging SDP codes
  // With manual SDP exchange, automatic ICE restart isn't feasible
  // Show "Connection lost" UI with manual reconnect option

  // After timeout, transition to failed state
  reconnectTimerRef.current = setTimeout(() => {
    console.log('[Sync] Reconnection not possible - manual SDP exchange required');
    setSyncState((prev) => ({
      ...prev,
      reconnectionState: {
        status: 'failed',
        reason: 'Connection lost. Manual reconnection required.',
      },
    }));
  }, RECONNECT_BASE_DELAY);
}, []);
```

4. Add handlePeerDisconnect function:
```typescript
/**
 * Handle peer explicitly disconnecting.
 * Do NOT auto-reconnect - this was intentional.
 * CONN-08: Graceful disconnect from peer.
 */
const handlePeerDisconnect = useCallback((reason: 'user_initiated' | 'error') => {
  console.log('[Sync] Peer disconnected:', reason);

  // Clear any reconnection attempts
  if (reconnectTimerRef.current) {
    clearTimeout(reconnectTimerRef.current);
    reconnectTimerRef.current = null;
  }

  // Transition to peer_disconnected state (no auto-reconnect)
  setSyncState((prev) => ({
    ...prev,
    reconnectionState: { status: 'peer_disconnected' },
    connectedAt: null,
  }));

  // Disconnect locally
  connectionRef.current?.disconnect();
  setConnectionState('disconnected');
}, []);
```

5. Add resetReconnectionState function:
```typescript
/**
 * Reset reconnection state - for "Try again" button.
 * Clears failed/peer_disconnected state so user can start fresh.
 */
const resetReconnectionState = useCallback(() => {
  if (reconnectTimerRef.current) {
    clearTimeout(reconnectTimerRef.current);
    reconnectTimerRef.current = null;
  }
  setSyncState((prev) => ({
    ...prev,
    reconnectionState: { status: 'idle' },
    connectedAt: null,
  }));
}, []);
```

6. Clean up reconnect timer on unmount - add to cleanup in setConnection when conn is null:
```typescript
if (!conn) {
  // Clear reconnect timer
  if (reconnectTimerRef.current) {
    clearTimeout(reconnectTimerRef.current);
    reconnectTimerRef.current = null;
  }
  audioTransferRef.current = null;
  setConnectionState('disconnected');
  hasInitialSyncedRef.current = false;
  setSyncState((prev) => ({
    ...prev,
    roleTransferState: { status: 'idle' },
    reconnectionState: { status: 'idle' },
    connectedAt: null,
  }));
}
```

7. Update the context value to include new fields:
```typescript
const value: SyncContextValue = {
  // ... existing fields ...
  reconnectionState: syncState.reconnectionState,
  connectedAt: syncState.connectedAt,
  resetReconnectionState,
};
```
  </action>
  <verify>
Run: `cd /Users/krunkosaurus/Documents/git/voice-cards && npm run typecheck`
TypeScript compiles without errors.
  </verify>
  <done>
SyncContext:
- Starts heartbeat when connection becomes 'connected'
- Handles heartbeat timeout -> transitions to 'reconnecting' then 'failed'
- Handles peer disconnect -> transitions to 'peer_disconnected' (no auto-reconnect)
- Exposes reconnectionState and connectedAt for UI
- Provides resetReconnectionState for "Try again" functionality
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run typecheck` passes
2. ReconnectionState type exists with idle/reconnecting/failed/peer_disconnected variants
3. Heartbeat starts when connectionState becomes 'connected'
4. Heartbeat timeout transitions to 'reconnecting' state
5. Peer disconnect transitions to 'peer_disconnected' state (no auto-reconnect)
6. resetReconnectionState clears state for manual retry
</verification>

<success_criteria>
- Heartbeat automatically starts when connected
- Heartbeat timeout detected and transitions to reconnecting state
- Peer disconnect message prevents auto-reconnection
- Reconnection state exposed to UI for display
- connectedAt timestamp recorded for duration display
- resetReconnectionState allows user to try again manually
</success_criteria>

<output>
After completion, create `.planning/phases/05-connection-polish/05-03-SUMMARY.md`
</output>
