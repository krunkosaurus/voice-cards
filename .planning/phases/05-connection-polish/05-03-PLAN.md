---
phase: 05-connection-polish
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - client/src/contexts/SyncContext.tsx
autonomous: true

must_haves:
  truths:
    - "Heartbeat starts automatically when connection becomes connected"
    - "User is notified when heartbeat timeout occurs (connection lost)"
    - "User sees brief 'reconnecting' state before 'connection lost' message"
    - "User must manually start new session after connection failure"
    - "Peer explicit disconnect shows 'peer disconnected' state (no auto-reconnect)"
  artifacts:
    - path: "client/src/contexts/SyncContext.tsx"
      provides: "ReconnectionState, heartbeat wiring, handleHeartbeatTimeout, handlePeerDisconnect, gracefulDisconnect"
      contains: "ReconnectionState"
  key_links:
    - from: "client/src/contexts/SyncContext.tsx"
      to: "client/src/services/webrtc/connection.ts"
      via: "onHeartbeatTimeout, onPeerDisconnect callbacks"
      pattern: "onHeartbeatTimeout"
---

<objective>
Add reconnection state machine to SyncContext for handling connection drops with graceful UI feedback.

Purpose: Implement CONN-07 (detect connection loss) and CONN-08 (graceful disconnect) by detecting heartbeat timeout, transitioning to "reconnecting" state briefly, then showing "failed" state with manual reconnect option. Due to manual SDP exchange in this project, automatic ICE restart isn't feasible - user must start a new connection.

Output: SyncContext with reconnection state machine, heartbeat integration, gracefulDisconnect method, and exposed reconnection status for UI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-connection-polish/05-CONTEXT.md
@.planning/phases/05-connection-polish/05-RESEARCH.md
@.planning/phases/05-connection-polish/05-01-SUMMARY.md
@.planning/phases/05-connection-polish/05-02-SUMMARY.md
@client/src/contexts/SyncContext.tsx
@client/src/services/webrtc/connection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reconnection state and types</name>
  <files>client/src/contexts/SyncContext.tsx</files>
  <action>
Add reconnection state management to SyncContext:

1. Add ReconnectionState type after RoleTransferState type:
```typescript
/**
 * Reconnection state for connection loss handling.
 * Note: Due to manual SDP exchange, automatic reconnection isn't possible.
 * User must start a new connection after failure.
 */
type ReconnectionState =
  | { status: 'idle' }
  | { status: 'reconnecting' }  // Brief state while detecting if connection recovers
  | { status: 'failed'; reason: string }  // Connection lost - manual reconnect required
  | { status: 'peer_disconnected' };  // Peer intentionally disconnected
```

2. Add reconnectionState to SyncState interface:
```typescript
interface SyncState {
  isSyncing: boolean;
  role: UserRole | null;
  progress: SyncProgress;
  pendingRequest: PendingSyncRequest | null;
  receivedProject: Project | null;
  receivedCards: Card[];
  receivedAudio: Map<string, Blob>;
  roleTransferState: RoleTransferState;
  reconnectionState: ReconnectionState;  // ADD THIS
  connectedAt: number | null;  // ADD THIS - timestamp when connected
}
```

3. Update initialSyncState:
```typescript
const initialSyncState: SyncState = {
  isSyncing: false,
  role: null,
  progress: initialProgress,
  pendingRequest: null,
  receivedProject: null,
  receivedCards: [],
  receivedAudio: new Map(),
  roleTransferState: { status: 'idle' },
  reconnectionState: { status: 'idle' },
  connectedAt: null,
};
```

4. Add reconnection config constant after initialSyncState:
```typescript
// Reconnection config - brief delay before showing "connection lost"
const RECONNECT_DETECT_DELAY = 2000;  // 2s to detect if connection self-recovers
```

5. Add to SyncContextValue interface:
```typescript
interface SyncContextValue {
  // ... existing fields ...

  // Reconnection state (CONN-07)
  reconnectionState: ReconnectionState;
  connectedAt: number | null;
  resetReconnectionState: () => void;  // For "Try again" button

  // Graceful disconnect (CONN-08)
  gracefulDisconnect: () => Promise<void>;
}
```
  </action>
  <verify>
Run: `cd /Users/krunkosaurus/Documents/git/voice-cards && npm run typecheck`
TypeScript compiles without errors.
  </verify>
  <done>
ReconnectionState type defined (simplified - no attempt counter since auto-reconnect isn't possible). SyncState includes reconnectionState and connectedAt. SyncContextValue exposes reconnectionState, connectedAt, resetReconnectionState, and gracefulDisconnect.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire heartbeat and implement connection event handlers</name>
  <files>client/src/contexts/SyncContext.tsx</files>
  <action>
Wire heartbeat callbacks and implement reconnection state logic:

1. Add ref for reconnection timer (after other refs):
```typescript
const reconnectTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
```

2. Modify setConnection callback to wire heartbeat callbacks:
Update the conn.setCallbacks call to include:
```typescript
conn.setCallbacks({
  onStateChange: (state) => {
    setConnectionState(state);

    // Start heartbeat when connected
    if (state === 'connected') {
      conn.startHeartbeat();
      // Record connection time
      setSyncState((prev) => ({
        ...prev,
        connectedAt: Date.now(),
        reconnectionState: { status: 'idle' },
      }));
    }

    // Stop heartbeat on disconnect/error
    if (state === 'disconnected' || state === 'error') {
      conn.stopHeartbeat();
    }
  },
  onControlMessage: (msg) => {
    // ... existing message routing ...
  },
  onBinaryMessage: (data) => {
    handleBinaryMessage(data);
  },
  onHeartbeatTimeout: () => {
    handleHeartbeatTimeout();
  },
  onPeerDisconnect: (reason) => {
    handlePeerDisconnect(reason);
  },
});
```

3. Add handleHeartbeatTimeout function (before setConnection):
```typescript
/**
 * Handle heartbeat timeout - connection is stale.
 * Show brief "reconnecting" state, then transition to "failed".
 *
 * CONN-07: Due to manual SDP exchange, automatic ICE restart isn't feasible.
 * User must start a new connection.
 */
const handleHeartbeatTimeout = useCallback(() => {
  console.log('[Sync] Heartbeat timeout - connection lost');

  // Show reconnecting state briefly (connection might self-recover)
  setConnectionState('reconnecting');
  setSyncState((prev) => ({
    ...prev,
    reconnectionState: { status: 'reconnecting' },
  }));

  // After brief delay, transition to failed state
  // (Manual SDP exchange means we can't auto-reconnect)
  reconnectTimerRef.current = setTimeout(() => {
    console.log('[Sync] Connection lost - manual reconnection required');
    setSyncState((prev) => ({
      ...prev,
      reconnectionState: {
        status: 'failed',
        reason: 'Connection lost. Please start a new session.',
      },
    }));
  }, RECONNECT_DETECT_DELAY);
}, []);
```

4. Add handlePeerDisconnect function:
```typescript
/**
 * Handle peer explicitly disconnecting.
 * Do NOT show reconnecting state - this was intentional.
 * CONN-08: Graceful disconnect from peer.
 */
const handlePeerDisconnect = useCallback((reason: 'user_initiated' | 'error') => {
  console.log('[Sync] Peer disconnected:', reason);

  // Clear any reconnection timer
  if (reconnectTimerRef.current) {
    clearTimeout(reconnectTimerRef.current);
    reconnectTimerRef.current = null;
  }

  // Transition to peer_disconnected state (no reconnecting state)
  setSyncState((prev) => ({
    ...prev,
    reconnectionState: { status: 'peer_disconnected' },
    connectedAt: null,
  }));

  // Disconnect locally
  connectionRef.current?.disconnect();
  setConnectionState('disconnected');
}, []);
```

5. Add resetReconnectionState function:
```typescript
/**
 * Reset reconnection state - for "Try again" button.
 * Clears failed/peer_disconnected state so user can start fresh connection.
 */
const resetReconnectionState = useCallback(() => {
  if (reconnectTimerRef.current) {
    clearTimeout(reconnectTimerRef.current);
    reconnectTimerRef.current = null;
  }
  setSyncState((prev) => ({
    ...prev,
    reconnectionState: { status: 'idle' },
    connectedAt: null,
  }));
}, []);
```

6. Add gracefulDisconnect function:
```typescript
/**
 * Graceful disconnect - notify peer before closing.
 * CONN-08: User-initiated disconnect sends message to peer.
 */
const gracefulDisconnect = useCallback(async () => {
  const conn = connectionRef.current;
  if (!conn) return;

  console.log('[Sync] Graceful disconnect initiated');
  await conn.gracefulDisconnect('user_initiated');

  // Clean up local state
  setSyncState((prev) => ({
    ...prev,
    reconnectionState: { status: 'idle' },
    connectedAt: null,
  }));
  setConnectionState('disconnected');
}, []);
```

7. Clean up reconnect timer on unmount - add to cleanup in setConnection when conn is null:
```typescript
if (!conn) {
  // Clear reconnect timer
  if (reconnectTimerRef.current) {
    clearTimeout(reconnectTimerRef.current);
    reconnectTimerRef.current = null;
  }
  audioTransferRef.current = null;
  setConnectionState('disconnected');
  hasInitialSyncedRef.current = false;
  setSyncState((prev) => ({
    ...prev,
    roleTransferState: { status: 'idle' },
    reconnectionState: { status: 'idle' },
    connectedAt: null,
  }));
}
```

8. Update the context value to include new fields:
```typescript
const value: SyncContextValue = {
  // ... existing fields ...
  reconnectionState: syncState.reconnectionState,
  connectedAt: syncState.connectedAt,
  resetReconnectionState,
  gracefulDisconnect,
};
```
  </action>
  <verify>
Run: `cd /Users/krunkosaurus/Documents/git/voice-cards && npm run typecheck`
TypeScript compiles without errors.
  </verify>
  <done>
SyncContext:
- Starts heartbeat when connection becomes 'connected'
- Handles heartbeat timeout -> brief 'reconnecting' state -> 'failed' (no attempt counter)
- Handles peer disconnect -> transitions to 'peer_disconnected' (no reconnecting state)
- Exposes reconnectionState and connectedAt for UI
- Provides resetReconnectionState for "Try again" functionality
- Provides gracefulDisconnect for user-initiated disconnect
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run typecheck` passes
2. ReconnectionState type exists with idle/reconnecting/failed/peer_disconnected variants
3. Heartbeat starts when connectionState becomes 'connected'
4. Heartbeat timeout shows 'reconnecting' briefly (2s) then 'failed'
5. Peer disconnect transitions directly to 'peer_disconnected' state
6. gracefulDisconnect sends disconnect message to peer before closing
7. resetReconnectionState clears state for manual retry
</verification>

<success_criteria>
- Heartbeat automatically starts when connected
- Heartbeat timeout shows brief "reconnecting" then "connection lost" message
- Peer disconnect message shows "peer disconnected" (no reconnecting state)
- gracefulDisconnect available for UI disconnect button
- Reconnection state exposed to UI for display
- connectedAt timestamp recorded for duration display
- resetReconnectionState allows user to start fresh session
</success_criteria>

<output>
After completion, create `.planning/phases/05-connection-polish/05-03-SUMMARY.md`
</output>
